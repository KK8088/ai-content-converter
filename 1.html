<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIå†…å®¹æ ¼å¼è½¬æ¢å·¥å…·</title>
    <script src="https://cdn.jsdelivr.net/npm/docx@7.8.2/build/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
        /* å¯¼å…¥ç°ä»£å­—ä½“ */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        /* CSSå˜é‡å®šä¹‰ */
        :root {
            --primary-color: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #a5b4fc;
            --secondary-color: #f59e0b;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
            --info-color: #3b82f6;

            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --text-muted: #9ca3af;

            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-tertiary: #f3f4f6;
            --bg-dark: #111827;

            --border-color: #e5e7eb;
            --border-light: #f3f4f6;

            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);

            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;

            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* å…¨å±€é‡ç½® */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* åŸºç¡€æ ·å¼ */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 1rem;
        }

        /* ä¸»å®¹å™¨ */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* å¤´éƒ¨åŒºåŸŸ */
        .header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 3rem 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="50" cy="50" r="1" fill="rgba(255,255,255,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.1;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            position: relative;
            z-index: 1;
        }

        .header .subtitle {
            font-size: 1.125rem;
            opacity: 0.9;
            font-weight: 400;
            position: relative;
            z-index: 1;
        }

        /* ä¸»è¦å†…å®¹åŒºåŸŸ */
        .main-content {
            padding: 2rem;
        }

        /* å¡ç‰‡æ ·å¼ */
        .card {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
        }

        .card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        /* è¾“å…¥åŒºåŸŸ */
        .input-section {
            margin-bottom: 2rem;
        }

        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 1.5rem;
            background: var(--primary-color);
            border-radius: 2px;
        }

        /* æ–‡æœ¬åŒºåŸŸæ ·å¼ */
        .textarea-container {
            position: relative;
            margin-bottom: 1rem;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            padding: 1rem;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            resize: vertical;
            transition: var(--transition);
            background: var(--bg-secondary);
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
            background: var(--bg-primary);
        }

        textarea::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        /* æ ¼å¼æç¤º */
        .format-hint {
            margin-top: 0.5rem;
            color: var(--text-muted);
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .format-hint::before {
            content: 'ğŸ’¡';
            font-size: 1rem;
        }

        /* é€‰é¡¹åŒºåŸŸ */
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .option-group {
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            padding: 1rem;
            border: 1px solid var(--border-color);
        }

        .option-label {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            display: block;
        }

        select, input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            transition: var(--transition);
            background: var(--bg-primary);
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        /* æŒ‰é’®æ ·å¼ */
        .btn-group {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        button {
            flex: 1;
            padding: 0.875rem 1.5rem;
            border: none;
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading {
            display: none;
            text-align: center;
            padding: 2rem;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin: 1rem 0;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* ç¤ºä¾‹åŒºåŸŸ */
        .examples {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border-radius: var(--radius-lg);
            padding: 2rem;
            margin-top: 2rem;
            border: 1px solid var(--border-light);
        }

        .examples h3 {
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .examples h3::before {
            content: 'ğŸ“š';
            font-size: 1.25rem;
        }

        .example-item {
            margin-bottom: 1.5rem;
        }

        .example-title {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        pre {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: 1rem;
            margin: 0.5rem 0;
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: 0.8rem;
            overflow-x: auto;
            line-height: 1.5;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            body {
                padding: 0.5rem;
            }

            .header {
                padding: 2rem 1rem;
            }

            .header h1 {
                font-size: 2rem;
            }

            .main-content {
                padding: 1rem;
            }

            .options-grid {
                grid-template-columns: 1fr;
            }

            .btn-group {
                flex-direction: column;
            }

            textarea {
                min-height: 250px;
                font-size: 0.8rem;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.75rem;
            }

            .header .subtitle {
                font-size: 1rem;
            }

            .card {
                padding: 1rem;
            }
        }

        /* åŠ¨ç”»æ•ˆæœ */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card {
            animation: fadeIn 0.6s ease-out;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å¤´éƒ¨åŒºåŸŸ -->
        <div class="header">
            <h1>AIå†…å®¹æ ¼å¼è½¬æ¢å·¥å…·</h1>
            <p class="subtitle">å°†AIå¯¹è¯å†…å®¹å®Œç¾è½¬æ¢ä¸ºä¸“ä¸šçš„Wordå’ŒExcelæ–‡æ¡£</p>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="main-content">
            <!-- è¾“å…¥åŒºåŸŸ -->
            <div class="card input-section">
                <h2 class="section-title">å†…å®¹è¾“å…¥</h2>
                <div class="textarea-container">
                    <textarea id="ai-content" placeholder="è¯·åœ¨æ­¤ç²˜è´´ä»ChatGPTã€DeepSeekç­‰AIå¯¹è¯ä¸­å¤åˆ¶çš„å†…å®¹...

æ”¯æŒçš„æ ¼å¼åŒ…æ‹¬ï¼š
â€¢ Markdownè¡¨æ ¼ (| åˆ—1 | åˆ—2 |)
â€¢ ä»£ç å— (```ä»£ç ```)
â€¢ åˆ—è¡¨é¡¹ç›® (- é¡¹ç›® æˆ– 1. é¡¹ç›®)
â€¢ å¼•ç”¨å†…å®¹ (> å¼•ç”¨)
â€¢ æ ‡é¢˜æ ¼å¼ (# æ ‡é¢˜)
â€¢ æ ¼å¼åŒ–æ–‡æœ¬ (**åŠ ç²—** *æ–œä½“* `ä»£ç `)

æ™ºèƒ½è¯†åˆ«å„ç§æ•°æ®ç±»å‹ï¼šè´§å¸ã€æ—¥æœŸã€ç™¾åˆ†æ¯”ç­‰"></textarea>
                </div>
                <div class="format-hint">
                    æ”¯æŒæ ¼å¼ï¼šMarkdownè¡¨æ ¼ã€ä»£ç å—ã€å¼•ç”¨ã€åˆ—è¡¨ã€é“¾æ¥ã€åŠ ç²—æ–œä½“ç­‰
                </div>
            </div>

            <!-- é€‰é¡¹åŒºåŸŸ -->
            <div class="card">
                <h2 class="section-title">è½¬æ¢é€‰é¡¹</h2>
                <div class="options-grid">
                    <div class="option-group">
                        <label class="option-label" for="content-type">å†…å®¹ç±»å‹</label>
                        <select id="content-type">
                            <option value="auto">ğŸ¤– æ™ºèƒ½æ£€æµ‹</option>
                            <option value="table">ğŸ“Š è¡¨æ ¼æ•°æ®</option>
                            <option value="list">ğŸ“‹ åˆ—è¡¨/é¡¹ç›®</option>
                            <option value="article">ğŸ“„ æ–‡ç« /æŠ¥å‘Š</option>
                            <option value="markdown">ğŸ“ Markdownæ ¼å¼</option>
                        </select>
                    </div>

                    <div class="option-group">
                        <label class="option-label" for="output-format">è¾“å‡ºæ ¼å¼</label>
                        <select id="output-format">
                            <option value="docx">ğŸ“„ Microsoft Word (.docx)</option>
                            <option value="xlsx">ğŸ“Š Microsoft Excel (.xlsx)</option>
                            <option value="both">ğŸ“„ğŸ“Š Wordå’ŒExcel</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- æ“ä½œæŒ‰é’® -->
            <div class="btn-group">
                <button id="convert-btn" class="btn-primary">
                    ğŸš€ å¼€å§‹è½¬æ¢
                </button>
                <button id="clear-btn" class="btn-secondary">
                    ğŸ—‘ï¸ æ¸…ç©ºå†…å®¹
                </button>
            </div>

            <!-- åŠ è½½çŠ¶æ€ -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p class="loading-text">æ­£åœ¨æ™ºèƒ½å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...</p>
            </div>
        
            <!-- ç¤ºä¾‹åŒºåŸŸ -->
            <div class="examples">
                <h3>æ ¼å¼ç¤ºä¾‹ä¸ä½¿ç”¨æŒ‡å—</h3>

                <div class="example-item">
                    <div class="example-title">ğŸ“Š Markdownè¡¨æ ¼</div>
                    <pre>| äº§å“åç§° | ä»·æ ¼ | åº“å­˜ | çŠ¶æ€ |
|----------|------|------|------|
| iPhone 15 Pro | Â¥8,999.00 | 50 | æœ‰è´§ |
| MacBook Air | $1,299.99 | 30 | æœ‰è´§ |
| iPad Pro | â‚¬999.50 | 25 | ç¼ºè´§ |</pre>
                </div>

                <div class="example-item">
                    <div class="example-title">ğŸ’» ä»£ç å—</div>
                    <pre>```javascript
function processData(data) {
    return data.map(item => ({
        id: item.id,
        value: parseFloat(item.value)
    }));
}
```</pre>
                </div>

                <div class="example-item">
                    <div class="example-title">ğŸ“‹ åˆ—è¡¨å’Œå¼•ç”¨</div>
                    <pre>## é¡¹ç›®æ¸…å•
- éœ€æ±‚åˆ†æ âœ…
- ç³»ç»Ÿè®¾è®¡ ğŸ”„
- å¼€å‘å®æ–½ â³

> **é‡è¦æç¤º**: è¯·ç¡®ä¿æ‰€æœ‰æ•°æ®å‡†ç¡®æ— è¯¯</pre>
                </div>

                <div class="example-item">
                    <div class="example-title">ğŸ¨ æ ¼å¼åŒ–æ–‡æœ¬</div>
                    <pre>**åŠ ç²—æ–‡æœ¬** *æ–œä½“æ–‡æœ¬* `è¡Œå†…ä»£ç `
[é“¾æ¥æ–‡æœ¬](https://example.com)
~~åˆ é™¤çº¿~~ __ä¸‹åˆ’çº¿__</pre>
                </div>

                <div class="example-item">
                    <div class="example-title">ğŸ’° æ•°æ®ç±»å‹æ”¯æŒ</div>
                    <pre>è´§å¸: Â¥1,250.50, $999.99, â‚¬850.00
ç™¾åˆ†æ¯”: 15.6%, -8.2%, +23.8%
æ—¥æœŸ: 2024-03-15, 2024å¹´3æœˆ16æ—¥
å¸ƒå°”: æ˜¯/å¦, âˆš/Ã—, true/false</pre>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        document.getElementById('convert-btn').addEventListener('click', convertContent);
        document.getElementById('clear-btn').addEventListener('click', () => {
            document.getElementById('ai-content').value = '';
        });

        // æ™ºèƒ½æ£€æµ‹å†…å®¹ç±»å‹ - å¢å¼ºç‰ˆ
        function detectContentType(content) {
            if (!content || !content.trim()) {
                return 'article';
            }

            const lines = content.split('\n').map(line => line.trim()).filter(line => line);
            const totalLines = lines.length;

            // è®¡ç®—å„ç§æ ¼å¼çš„æƒé‡
            let markdownScore = 0;
            let tableScore = 0;
            let listScore = 0;
            let codeScore = 0;

            // æ£€æµ‹Markdownè¡¨æ ¼ - æ›´ä¸¥æ ¼çš„æ£€æµ‹
            const tableLines = lines.filter(line => line.includes('|'));
            const separatorLines = lines.filter(line => /^\|?[\s]*:?-+:?[\s]*\|/.test(line) || /^[\s]*:?-+:?[\s]*\|/.test(line));

            if (tableLines.length >= 2 && separatorLines.length >= 1) {
                // æ£€æŸ¥è¡¨æ ¼ç»“æ„çš„ä¸€è‡´æ€§
                const tableLinesWithPipes = tableLines.filter(line => {
                    const pipeCount = (line.match(/\|/g) || []).length;
                    return pipeCount >= 2; // è‡³å°‘éœ€è¦2ä¸ªç®¡é“ç¬¦å½¢æˆè¡¨æ ¼
                });

                if (tableLinesWithPipes.length >= 2) {
                    tableScore += 50;
                    markdownScore += 30;
                }
            }

            // æ£€æµ‹ä»£ç å—
            const codeBlockMatches = content.match(/```[\s\S]*?```/g);
            if (codeBlockMatches) {
                codeScore += codeBlockMatches.length * 20;
                markdownScore += 25;
            }

            // æ£€æµ‹å•è¡Œä»£ç å—ï¼ˆæ²¡æœ‰ç»“æŸæ ‡è®°çš„ï¼‰
            if (content.includes('```')) {
                markdownScore += 15;
            }

            // æ£€æµ‹å¼•ç”¨å—
            const quoteLines = lines.filter(line => /^>\s/.test(line));
            if (quoteLines.length > 0) {
                markdownScore += quoteLines.length * 5;
            }

            // æ£€æµ‹Markdownæ ‡é¢˜
            const headingLines = lines.filter(line => /^#{1,6}\s/.test(line));
            if (headingLines.length > 0) {
                markdownScore += headingLines.length * 10;
            }

            // æ£€æµ‹åˆ—è¡¨
            const unorderedListLines = lines.filter(line => /^[-*+]\s/.test(line));
            const orderedListLines = lines.filter(line => /^\d+\.\s/.test(line));
            const totalListLines = unorderedListLines.length + orderedListLines.length;

            if (totalListLines > 0) {
                listScore += totalListLines * 8;
                markdownScore += totalListLines * 5;
            }

            // æ£€æµ‹Markdowné“¾æ¥å’Œæ ¼å¼
            const linkMatches = content.match(/\[([^\]]+)\]\(([^)]+)\)/g);
            if (linkMatches) {
                markdownScore += linkMatches.length * 3;
            }

            const boldMatches = content.match(/\*\*([^*]+)\*\*/g);
            if (boldMatches) {
                markdownScore += boldMatches.length * 2;
            }

            const italicMatches = content.match(/\*([^*]+)\*/g);
            if (italicMatches) {
                markdownScore += italicMatches.length * 1;
            }

            // æ£€æµ‹ç®€å•CSV
            if (isSimpleCSV(content)) {
                tableScore += 40;
            }

            // æ£€æµ‹åˆ†éš”çº¿
            const separatorCount = lines.filter(line => /^-{3,}$/.test(line)).length;
            if (separatorCount > 0) {
                markdownScore += separatorCount * 5;
            }

            // æ ¹æ®æƒé‡å†³å®šå†…å®¹ç±»å‹
            const maxScore = Math.max(markdownScore, tableScore, listScore, codeScore);

            // å¦‚æœè¡¨æ ¼åˆ†æ•°æœ€é«˜ä¸”è¶…è¿‡é˜ˆå€¼
            if (tableScore >= 30 && tableScore === maxScore) {
                return 'table';
            }

            // å¦‚æœMarkdownåˆ†æ•°è¶…è¿‡é˜ˆå€¼
            if (markdownScore >= 15) {
                return 'markdown';
            }

            // å¦‚æœä¸»è¦æ˜¯åˆ—è¡¨å†…å®¹
            if (listScore >= 20 && totalListLines / totalLines > 0.5) {
                return 'list';
            }

            // é»˜è®¤ä¸ºæ–‡ç« 
            return 'article';
        }

        function isSimpleCSV(content) {
            const lines = content.split('\n').filter(line => line.trim());
            if (lines.length < 2) return false;

            // æ£€æŸ¥æ˜¯å¦åŒ…å«Markdownè¡¨æ ¼æ ‡è®°
            if (content.includes('|') || content.includes('---')) {
                return false;
            }

            const firstLineCommas = (lines[0].match(/,/g) || []).length;
            if (firstLineCommas === 0) return false;

            // æ£€æŸ¥åˆ—æ•°ä¸€è‡´æ€§
            let consistentLines = 0;
            for (const line of lines) {
                const commas = (line.match(/,/g) || []).length;
                if (Math.abs(commas - firstLineCommas) <= 1) {
                    consistentLines++;
                }
            }

            // è‡³å°‘80%çš„è¡Œéœ€è¦æœ‰ä¸€è‡´çš„åˆ—æ•°
            const consistency = consistentLines / lines.length;
            return consistency >= 0.8 && firstLineCommas >= 1;
        }

        async function convertContent() {
            const content = document.getElementById('ai-content').value.trim();
            if (!content) {
                alert('è¯·è¾“å…¥è¦è½¬æ¢çš„å†…å®¹');
                return;
            }

            const contentType = document.getElementById('content-type').value;
            const outputFormat = document.getElementById('output-format').value;
            
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            
            try {
                // æ¨¡æ‹Ÿå¼‚æ­¥å¤„ç†
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                if (outputFormat === 'docx' || outputFormat === 'both') {
                    await generateDocx(content, contentType);
                }
                
                if (outputFormat === 'xlsx' || outputFormat === 'both') {
                    await generateXlsx(content, contentType);
                }
            } catch (error) {
                console.error('è½¬æ¢é”™è¯¯:', error);
                alert('è½¬æ¢è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ' + error.message);
            } finally {
                loading.style.display = 'none';
            }
        }

        async function generateDocx(content, contentType) {
            const {
                Document, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell,
                AlignmentType, BorderStyle, WidthType, LevelFormat, convertInchesToTwip,
                ShadingType, UnderlineType, ExternalHyperlink
            } = docx;

            const children = [];

            // æ™ºèƒ½æ£€æµ‹å†…å®¹ç±»å‹
            if (contentType === 'auto') {
                contentType = detectContentType(content);
            }

            // æ ¹æ®å†…å®¹ç±»å‹å¤„ç†
            if (contentType === 'table' || (contentType === 'auto' && isSimpleCSV(content))) {
                // è¡¨æ ¼æ•°æ®å¤„ç†
                const rows = content.split('\n').filter(row => row.trim());
                const tableRows = [];

                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    const isHeader = i === 0;
                    const cells = row.split(',').map(cell =>
                        new TableCell({
                            children: [new Paragraph({
                                children: [new TextRun({
                                    text: cell.trim(),
                                    bold: isHeader,
                                    font: "å¾®è½¯é›…é»‘",
                                    size: isHeader ? 24 : 22
                                })],
                                alignment: isHeader ? AlignmentType.CENTER : AlignmentType.LEFT
                            })],
                            shading: isHeader ? {
                                fill: "E6F3FF",
                                color: "auto"
                            } : undefined,
                            margins: {
                                top: convertInchesToTwip(0.1),
                                bottom: convertInchesToTwip(0.1),
                                left: convertInchesToTwip(0.15),
                                right: convertInchesToTwip(0.15)
                            },
                            borders: {
                                top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }
                            }
                        })
                    );
                    tableRows.push(new TableRow({
                        children: cells,
                        tableHeader: isHeader
                    }));
                }

                children.push(new Table({
                    rows: tableRows,
                    width: {
                        size: 100,
                        type: WidthType.PERCENTAGE
                    }
                }));
            } else if (contentType === 'list' || (contentType === 'auto' && content.startsWith('-'))) {
                // åˆ—è¡¨æ•°æ®å¤„ç†
                const items = content.split('\n').filter(line => line.trim());
                for (const item of items) {
                    const cleanText = item.replace(/^- /, '').trim();
                    children.push(new Paragraph({
                        children: [new TextRun({
                            text: cleanText,
                            font: "å¾®è½¯é›…é»‘",
                            size: 22
                        })],
                        bullet: {
                            level: 0
                        },
                        spacing: {
                            after: 120
                        }
                    }));
                }
            } else if (contentType === 'markdown') {
                // é«˜çº§Markdownè§£æ
                const parsedElements = parseMarkdown(content);
                children.push(...parsedElements);
            } else {
                // ç®€å•æ–‡æœ¬å¤„ç†
                const parsedElements = parseSimpleText(content);
                children.push(...parsedElements);
            }

            // è§£æMarkdownå†…å®¹
            function parseMarkdown(content) {
                const elements = [];
                const lines = content.split('\n');
                let i = 0;

                while (i < lines.length) {
                    const line = lines[i];

                    // è·³è¿‡ç©ºè¡Œ
                    if (!line.trim()) {
                        i++;
                        continue;
                    }

                    // è§£æä»£ç å—
                    if (line.startsWith('```')) {
                        const codeBlock = parseCodeBlock(lines, i);
                        elements.push(...codeBlock.elements);
                        i = codeBlock.nextIndex;
                        continue;
                    }

                    // è§£æè¡¨æ ¼
                    if (line.includes('|') && i + 1 < lines.length && lines[i + 1].includes('---')) {
                        const table = parseMarkdownTable(lines, i);
                        elements.push(table.element);
                        i = table.nextIndex;
                        continue;
                    }

                    // è§£ææ ‡é¢˜
                    if (line.match(/^#{1,6}\s/)) {
                        elements.push(parseHeading(line));
                        i++;
                        continue;
                    }

                    // è§£æå¼•ç”¨å—
                    if (line.startsWith('> ')) {
                        const quote = parseQuoteBlock(lines, i);
                        elements.push(quote.element);
                        i = quote.nextIndex;
                        continue;
                    }

                    // è§£æåˆ—è¡¨
                    if (line.match(/^[-*+]\s/) || line.match(/^\d+\.\s/)) {
                        const list = parseList(lines, i);
                        elements.push(...list.elements);
                        i = list.nextIndex;
                        continue;
                    }

                    // è§£æåˆ†éš”çº¿
                    if (line.match(/^---+$/)) {
                        elements.push(createSeparatorLine());
                        i++;
                        continue;
                    }

                    // è§£ææ™®é€šæ®µè½
                    const paragraph = parseParagraph(lines, i);
                    if (paragraph.element) {
                        elements.push(paragraph.element);
                    }
                    i = paragraph.nextIndex;
                }

                return elements;
            }

            // è§£æç®€å•æ–‡æœ¬
            function parseSimpleText(content) {
                const elements = [];
                const lines = content.split('\n');
                let currentParagraph = '';

                for (const line of lines) {
                    if (line.trim() === '') {
                        if (currentParagraph.trim()) {
                            elements.push(createStyledParagraph(currentParagraph.trim()));
                            currentParagraph = '';
                        }
                    } else if (line.startsWith('# ')) {
                        if (currentParagraph.trim()) {
                            elements.push(createStyledParagraph(currentParagraph.trim()));
                            currentParagraph = '';
                        }
                        elements.push(parseHeading(line));
                    } else if (line.startsWith('## ')) {
                        if (currentParagraph.trim()) {
                            elements.push(createStyledParagraph(currentParagraph.trim()));
                            currentParagraph = '';
                        }
                        elements.push(parseHeading(line));
                    } else if (line.startsWith('### ')) {
                        if (currentParagraph.trim()) {
                            elements.push(createStyledParagraph(currentParagraph.trim()));
                            currentParagraph = '';
                        }
                        elements.push(parseHeading(line));
                    } else {
                        currentParagraph += (currentParagraph ? ' ' : '') + line.trim();
                    }
                }

                if (currentParagraph.trim()) {
                    elements.push(createStyledParagraph(currentParagraph.trim()));
                }

                return elements;
            }

            function createStyledParagraph(text) {
                return new Paragraph({
                    children: parseInlineFormatting(text),
                    alignment: AlignmentType.JUSTIFIED,
                    spacing: {
                        after: 120,
                        line: 276
                    },
                    indent: {
                        firstLine: convertInchesToTwip(0.5)
                    }
                });
            }

            // è§£ææ ‡é¢˜
            function parseHeading(line) {
                const match = line.match(/^(#{1,6})\s(.+)$/);
                if (!match) return null;

                const level = match[1].length;
                const text = match[2].trim();
                const headingLevels = [
                    HeadingLevel.HEADING_1, HeadingLevel.HEADING_2, HeadingLevel.HEADING_3,
                    HeadingLevel.HEADING_4, HeadingLevel.HEADING_5, HeadingLevel.HEADING_6
                ];
                const colors = ["2E5BBA", "4472C4", "5B9BD5", "70AD47", "FFC000", "C55A11"];
                const sizes = [32, 28, 24, 22, 20, 18];

                return new Paragraph({
                    children: [new TextRun({
                        text: text,
                        font: "å¾®è½¯é›…é»‘",
                        size: sizes[level - 1],
                        bold: true,
                        color: colors[level - 1]
                    })],
                    heading: headingLevels[level - 1],
                    alignment: AlignmentType.LEFT,
                    spacing: {
                        before: level === 1 ? 240 : 200 - (level - 1) * 20,
                        after: level === 1 ? 120 : 100 - (level - 1) * 10
                    }
                });
            }

            // è§£æä»£ç å—
            function parseCodeBlock(lines, startIndex) {
                const elements = [];
                let i = startIndex + 1;
                const codeLines = [];
                let language = lines[startIndex].substring(3).trim();

                while (i < lines.length && !lines[i].startsWith('```')) {
                    codeLines.push(lines[i]);
                    i++;
                }

                const codeText = codeLines.join('\n');

                elements.push(new Paragraph({
                    children: [new TextRun({
                        text: codeText,
                        font: "Consolas",
                        size: 20
                    })],
                    shading: {
                        fill: "F8F8F8",
                        color: "auto"
                    },
                    spacing: {
                        before: 120,
                        after: 120
                    },
                    indent: {
                        left: convertInchesToTwip(0.5)
                    },
                    border: {
                        left: {
                            color: "CCCCCC",
                            space: 1,
                            style: "single",
                            size: 4
                        }
                    }
                }));

                return { elements, nextIndex: i + 1 };
            }

            // è§£æMarkdownè¡¨æ ¼
            function parseMarkdownTable(lines, startIndex) {
                const tableRows = [];
                let i = startIndex;

                // è§£æè¡¨å¤´
                const headerLine = lines[i].trim();
                const headers = headerLine.split('|').map(h => h.trim()).filter(h => h);

                // è·³è¿‡åˆ†éš”çº¿
                i += 2;

                // åˆ›å»ºè¡¨å¤´è¡Œ
                const headerCells = headers.map(header =>
                    new TableCell({
                        children: [new Paragraph({
                            children: [new TextRun({
                                text: header,
                                font: "å¾®è½¯é›…é»‘",
                                size: 24,
                                bold: true
                            })],
                            alignment: AlignmentType.CENTER
                        })],
                        shading: {
                            fill: "E6F3FF",
                            color: "auto"
                        },
                        margins: {
                            top: convertInchesToTwip(0.1),
                            bottom: convertInchesToTwip(0.1),
                            left: convertInchesToTwip(0.15),
                            right: convertInchesToTwip(0.15)
                        },
                        borders: {
                            top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                            bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                            left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                            right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }
                        }
                    })
                );

                tableRows.push(new TableRow({
                    children: headerCells,
                    tableHeader: true
                }));

                // è§£ææ•°æ®è¡Œ
                while (i < lines.length && lines[i].includes('|')) {
                    const rowLine = lines[i].trim();
                    const cells = rowLine.split('|').map(c => c.trim()).filter(c => c);

                    const rowCells = cells.map(cell =>
                        new TableCell({
                            children: [new Paragraph({
                                children: parseInlineFormatting(cell),
                                alignment: AlignmentType.LEFT
                            })],
                            margins: {
                                top: convertInchesToTwip(0.1),
                                bottom: convertInchesToTwip(0.1),
                                left: convertInchesToTwip(0.15),
                                right: convertInchesToTwip(0.15)
                            },
                            borders: {
                                top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }
                            }
                        })
                    );

                    tableRows.push(new TableRow({ children: rowCells }));
                    i++;
                }

                const table = new Table({
                    rows: tableRows,
                    width: {
                        size: 100,
                        type: WidthType.PERCENTAGE
                    }
                });

                return { element: table, nextIndex: i };
            }

            // è§£æå¼•ç”¨å—
            function parseQuoteBlock(lines, startIndex) {
                const quoteLines = [];
                let i = startIndex;

                while (i < lines.length && lines[i].startsWith('> ')) {
                    quoteLines.push(lines[i].substring(2).trim());
                    i++;
                }

                const quoteText = quoteLines.join(' ');

                const element = new Paragraph({
                    children: [new TextRun({
                        text: quoteText,
                        font: "å¾®è½¯é›…é»‘",
                        size: 22,
                        italics: true,
                        color: "666666"
                    })],
                    shading: {
                        fill: "F5F5F5",
                        color: "auto"
                    },
                    spacing: {
                        before: 120,
                        after: 120
                    },
                    indent: {
                        left: convertInchesToTwip(0.5)
                    },
                    border: {
                        left: {
                            color: "4472C4",
                            space: 1,
                            style: "single",
                            size: 6
                        }
                    }
                });

                return { element, nextIndex: i };
            }

            // è§£æåˆ—è¡¨
            function parseList(lines, startIndex) {
                const elements = [];
                let i = startIndex;

                while (i < lines.length) {
                    const line = lines[i];
                    if (!line.match(/^[-*+]\s/) && !line.match(/^\d+\.\s/)) {
                        break;
                    }

                    const isOrdered = line.match(/^\d+\.\s/);
                    const text = line.replace(/^[-*+]\s/, '').replace(/^\d+\.\s/, '').trim();

                    elements.push(new Paragraph({
                        children: parseInlineFormatting(text),
                        bullet: isOrdered ? undefined : { level: 0 },
                        numbering: isOrdered ? { reference: "my-numbering", level: 0 } : undefined,
                        spacing: {
                            after: 120
                        }
                    }));

                    i++;
                }

                return { elements, nextIndex: i };
            }

            // è§£ææ®µè½
            function parseParagraph(lines, startIndex) {
                let text = '';
                let i = startIndex;

                while (i < lines.length && lines[i].trim() &&
                       !lines[i].match(/^#{1,6}\s/) &&
                       !lines[i].startsWith('```') &&
                       !lines[i].startsWith('> ') &&
                       !lines[i].match(/^[-*+]\s/) &&
                       !lines[i].match(/^\d+\.\s/) &&
                       !lines[i].includes('|')) {
                    text += (text ? ' ' : '') + lines[i].trim();
                    i++;
                }

                if (!text.trim()) {
                    return { element: null, nextIndex: i + 1 };
                }

                const element = new Paragraph({
                    children: parseInlineFormatting(text),
                    alignment: AlignmentType.JUSTIFIED,
                    spacing: {
                        after: 120,
                        line: 276
                    },
                    indent: {
                        firstLine: convertInchesToTwip(0.5)
                    }
                });

                return { element, nextIndex: i };
            }

            // è§£æè¡Œå†…æ ¼å¼
            function parseInlineFormatting(text) {
                const runs = [];
                let currentText = text;

                // ç®€åŒ–çš„è¡Œå†…æ ¼å¼è§£æ
                const parts = currentText.split(/(\*\*[^*]+\*\*|\*[^*]+\*|`[^`]+`|\[[^\]]+\]\([^)]+\))/);

                for (const part of parts) {
                    if (!part) continue;

                    if (part.startsWith('**') && part.endsWith('**')) {
                        // åŠ ç²—
                        runs.push(new TextRun({
                            text: part.slice(2, -2),
                            bold: true,
                            font: "å¾®è½¯é›…é»‘",
                            size: 22
                        }));
                    } else if (part.startsWith('*') && part.endsWith('*')) {
                        // æ–œä½“
                        runs.push(new TextRun({
                            text: part.slice(1, -1),
                            italics: true,
                            font: "å¾®è½¯é›…é»‘",
                            size: 22
                        }));
                    } else if (part.startsWith('`') && part.endsWith('`')) {
                        // è¡Œå†…ä»£ç 
                        runs.push(new TextRun({
                            text: part.slice(1, -1),
                            font: "Consolas",
                            size: 20,
                            shading: {
                                fill: "F0F0F0",
                                color: "auto"
                            }
                        }));
                    } else if (part.match(/\[[^\]]+\]\([^)]+\)/)) {
                        // é“¾æ¥
                        const linkMatch = part.match(/\[([^\]]+)\]\(([^)]+)\)/);
                        if (linkMatch) {
                            runs.push(new TextRun({
                                text: linkMatch[1],
                                font: "å¾®è½¯é›…é»‘",
                                size: 22,
                                color: "0563C1",
                                underline: {
                                    type: UnderlineType.SINGLE,
                                    color: "0563C1"
                                }
                            }));
                        }
                    } else {
                        // æ™®é€šæ–‡æœ¬
                        runs.push(new TextRun({
                            text: part,
                            font: "å¾®è½¯é›…é»‘",
                            size: 22
                        }));
                    }
                }

                return runs.length > 0 ? runs : [new TextRun({
                    text: text,
                    font: "å¾®è½¯é›…é»‘",
                    size: 22
                })];
            }

            // åˆ›å»ºåˆ†éš”çº¿
            function createSeparatorLine() {
                return new Paragraph({
                    children: [new TextRun("")],
                    border: {
                        bottom: {
                            color: "CCCCCC",
                            space: 1,
                            style: "single",
                            size: 6
                        }
                    },
                    spacing: {
                        before: 120,
                        after: 120
                    }
                });
            }

            const doc = new Document({
                creator: "AIå†…å®¹æ ¼å¼è½¬æ¢å·¥å…·",
                title: "è½¬æ¢æ–‡æ¡£",
                description: "ç”±AIå†…å®¹æ ¼å¼è½¬æ¢å·¥å…·ç”Ÿæˆ",
                styles: {
                    paragraphStyles: [
                        {
                            id: "Normal",
                            name: "Normal",
                            basedOn: "Normal",
                            next: "Normal",
                            run: {
                                font: "å¾®è½¯é›…é»‘",
                                size: 22
                            },
                            paragraph: {
                                spacing: {
                                    line: 276,
                                    after: 120
                                }
                            }
                        }
                    ]
                },
                numbering: {
                    config: [
                        {
                            reference: "my-bullet-points",
                            levels: [
                                {
                                    level: 0,
                                    format: LevelFormat.BULLET,
                                    text: "â—",
                                    alignment: AlignmentType.LEFT,
                                    style: {
                                        paragraph: {
                                            indent: {
                                                left: convertInchesToTwip(0.5),
                                                hanging: convertInchesToTwip(0.25)
                                            }
                                        }
                                    }
                                }
                            ]
                        },
                        {
                            reference: "my-numbering",
                            levels: [
                                {
                                    level: 0,
                                    format: LevelFormat.DECIMAL,
                                    text: "%1.",
                                    alignment: AlignmentType.LEFT,
                                    style: {
                                        paragraph: {
                                            indent: {
                                                left: convertInchesToTwip(0.5),
                                                hanging: convertInchesToTwip(0.25)
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    ]
                },
                sections: [{
                    properties: {
                        page: {
                            margin: {
                                top: convertInchesToTwip(1),
                                right: convertInchesToTwip(1),
                                bottom: convertInchesToTwip(1),
                                left: convertInchesToTwip(1)
                            }
                        }
                    },
                    children: children
                }]
            });

            // ç”Ÿæˆå¹¶ä¸‹è½½DOCXæ–‡ä»¶
            const blob = await docx.Packer.toBlob(doc);
            saveAs(blob, 'converted_content.docx');
        }

        async function generateXlsx(content, contentType) {
            const workbook = XLSX.utils.book_new();

            // æ™ºèƒ½æ£€æµ‹å†…å®¹ç±»å‹
            if (contentType === 'auto') {
                contentType = detectContentType(content);
            }

            if (contentType === 'markdown') {
                // å¤„ç†Markdownå†…å®¹ï¼Œæå–æ‰€æœ‰è¡¨æ ¼
                const tables = safeExtractTables(content);
                if (tables.length > 0) {
                    // å¤„ç†å¤šä¸ªè¡¨æ ¼
                    tables.forEach((table, index) => {
                        try {
                            const safeTitle = (table.title || `è¡¨æ ¼${index + 1}`).substring(0, 31); // Excelå·¥ä½œè¡¨åé™åˆ¶
                            const worksheet = createStyledWorksheet(table.data, safeTitle);
                            XLSX.utils.book_append_sheet(workbook, worksheet, safeTitle);
                        } catch (error) {
                            console.warn(`è¡¨æ ¼${index + 1}å¤„ç†å‡ºé”™:`, error);
                            // åˆ›å»ºç®€å•çš„é”™è¯¯è¡¨æ ¼
                            const errorData = [['é”™è¯¯', 'è¡¨æ ¼å¤„ç†å¤±è´¥'], ['åŸå› ', error.message || 'æœªçŸ¥é”™è¯¯']];
                            const errorSheet = createStyledWorksheet(errorData, `é”™è¯¯${index + 1}`);
                            XLSX.utils.book_append_sheet(workbook, errorSheet, `é”™è¯¯${index + 1}`);
                        }
                    });
                } else {
                    // æ²¡æœ‰è¡¨æ ¼ï¼Œå¤„ç†å…¶ä»–å†…å®¹
                    const worksheet = createContentWorksheet(content);
                    XLSX.utils.book_append_sheet(workbook, worksheet, "å†…å®¹");
                }
            } else if (contentType === 'table' || isSimpleCSV(content)) {
                // ç®€å•CSVè¡¨æ ¼å¤„ç†
                const rows = content.split('\n').filter(row => row.trim()).map(row => row.split(',').map(cell => cell.trim()));
                const worksheet = createStyledWorksheet(rows, "æ•°æ®è¡¨");
                XLSX.utils.book_append_sheet(workbook, worksheet, "æ•°æ®è¡¨");
            } else if (contentType === 'list') {
                // åˆ—è¡¨æ•°æ®å¤„ç†
                const items = content.split('\n').filter(line => line.trim());
                const listData = [['é¡¹ç›®', 'å†…å®¹']];
                items.forEach((item, index) => {
                    const cleanText = item.replace(/^[-*+]\s/, '').replace(/^\d+\.\s/, '').trim();
                    listData.push([index + 1, cleanText]);
                });
                const worksheet = createStyledWorksheet(listData, "åˆ—è¡¨æ•°æ®");
                XLSX.utils.book_append_sheet(workbook, worksheet, "åˆ—è¡¨æ•°æ®");
            } else {
                // æ™®é€šæ–‡æœ¬å¤„ç†
                const worksheet = createContentWorksheet(content);
                XLSX.utils.book_append_sheet(workbook, worksheet, "æ–‡æœ¬å†…å®¹");
            }

            // ç”Ÿæˆå¹¶ä¸‹è½½XLSXæ–‡ä»¶
            XLSX.writeFile(workbook, 'converted_content.xlsx');
        }

        // æå–Markdownè¡¨æ ¼ - å¢å¼ºç‰ˆ
        function extractMarkdownTables(content) {
            const tables = [];
            const lines = content.split('\n');
            let i = 0;
            let currentTitle = '';

            while (i < lines.length) {
                const line = lines[i].trim();

                // è·³è¿‡ç©ºè¡Œ
                if (!line) {
                    i++;
                    continue;
                }

                // æ£€æµ‹æ ‡é¢˜
                if (line.match(/^#{1,6}\s/)) {
                    currentTitle = line.replace(/^#{1,6}\s/, '').trim();
                    i++;
                    continue;
                }

                // æ£€æµ‹è¡¨æ ¼å¼€å§‹ - æ›´çµæ´»çš„æ£€æµ‹
                if (isTableStart(lines, i)) {
                    const tableResult = parseTable(lines, i, currentTitle || `è¡¨æ ¼${tables.length + 1}`);
                    if (tableResult.data.length > 0) {
                        tables.push(tableResult);
                    }
                    i = tableResult.nextIndex;
                    currentTitle = ''; // é‡ç½®æ ‡é¢˜
                    continue;
                }

                i++;
            }

            return tables;
        }

        // æ£€æµ‹è¡¨æ ¼å¼€å§‹
        function isTableStart(lines, index) {
            if (index >= lines.length) return false;

            const currentLine = lines[index].trim();
            if (!currentLine.includes('|')) return false;

            // æ£€æŸ¥ä¸‹ä¸€è¡Œæ˜¯å¦ä¸ºåˆ†éš”çº¿
            if (index + 1 < lines.length) {
                const nextLine = lines[index + 1].trim();
                // æ›´çµæ´»çš„åˆ†éš”çº¿æ£€æµ‹
                if (isSeparatorLine(nextLine)) {
                    return true;
                }
            }

            // å¦‚æœæ²¡æœ‰åˆ†éš”çº¿ï¼Œæ£€æŸ¥æ˜¯å¦ä¸ºè¿ç»­çš„è¡¨æ ¼è¡Œ
            if (index + 1 < lines.length) {
                const nextLine = lines[index + 1].trim();
                if (nextLine.includes('|')) {
                    // æ£€æŸ¥ç®¡é“ç¬¦æ•°é‡æ˜¯å¦ç›¸ä¼¼
                    const currentPipes = (currentLine.match(/\|/g) || []).length;
                    const nextPipes = (nextLine.match(/\|/g) || []).length;
                    return Math.abs(currentPipes - nextPipes) <= 1 && currentPipes >= 2;
                }
            }

            return false;
        }

        // æ£€æµ‹åˆ†éš”çº¿
        function isSeparatorLine(line) {
            // æ ‡å‡†Markdownåˆ†éš”çº¿
            if (/^\|?[\s]*:?-+:?[\s]*(\|[\s]*:?-+:?[\s]*)*\|?$/.test(line)) {
                return true;
            }
            // ç®€åŒ–çš„åˆ†éš”çº¿
            if (/^[-|:\s]+$/.test(line) && line.includes('-')) {
                return true;
            }
            return false;
        }

        // è§£æè¡¨æ ¼
        function parseTable(lines, startIndex, title) {
            const tableData = [];
            let i = startIndex;

            // è§£æè¡¨å¤´
            const headerLine = lines[i].trim();
            const headers = parseTableRow(headerLine);
            if (headers.length > 0) {
                tableData.push(headers);
                i++;
            }

            // è·³è¿‡åˆ†éš”çº¿ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (i < lines.length && isSeparatorLine(lines[i].trim())) {
                i++;
            }

            // è§£ææ•°æ®è¡Œ
            while (i < lines.length) {
                const line = lines[i].trim();
                if (!line) {
                    i++;
                    continue;
                }

                if (!line.includes('|')) {
                    break;
                }

                const cells = parseTableRow(line);
                if (cells.length > 0) {
                    // ç¡®ä¿åˆ—æ•°ä¸€è‡´æ€§
                    while (cells.length < headers.length) {
                        cells.push('');
                    }
                    if (cells.length > headers.length) {
                        cells.splice(headers.length);
                    }
                    tableData.push(cells);
                }
                i++;
            }

            return {
                title: title,
                data: tableData,
                nextIndex: i
            };
        }

        // è§£æè¡¨æ ¼è¡Œ
        function parseTableRow(line) {
            if (!line || !line.includes('|')) return [];

            // ç§»é™¤é¦–å°¾çš„ç®¡é“ç¬¦
            let cleanLine = line.trim();
            if (cleanLine.startsWith('|')) {
                cleanLine = cleanLine.substring(1);
            }
            if (cleanLine.endsWith('|')) {
                cleanLine = cleanLine.substring(0, cleanLine.length - 1);
            }

            // åˆ†å‰²å¹¶æ¸…ç†å•å…ƒæ ¼
            return cleanLine.split('|')
                .map(cell => cleanCellContent(cell.trim()))
                .filter((cell, index, arr) => {
                    // ä¿ç•™ç©ºå•å…ƒæ ¼ï¼Œä½†ç§»é™¤å®Œå…¨ç©ºçš„å°¾éƒ¨å•å…ƒæ ¼
                    if (index === arr.length - 1 && cell === '') {
                        return false;
                    }
                    return true;
                });
        }

        // åˆ›å»ºå¸¦æ ·å¼çš„å·¥ä½œè¡¨
        function createStyledWorksheet(data, title) {
            const worksheet = XLSX.utils.aoa_to_sheet(data);

            // è®¾ç½®åˆ—å®½
            const colWidths = [];
            if (data.length > 0) {
                for (let col = 0; col < data[0].length; col++) {
                    let maxWidth = 10;
                    for (let row = 0; row < data.length; row++) {
                        if (data[row][col]) {
                            const cellLength = String(data[row][col]).length;
                            maxWidth = Math.max(maxWidth, Math.min(cellLength * 1.2, 50));
                        }
                    }
                    colWidths.push({ width: maxWidth });
                }
            }
            worksheet['!cols'] = colWidths;

            // è®¾ç½®è¡Œé«˜
            const rowHeights = data.map(() => ({ height: 20 }));
            if (rowHeights.length > 0) {
                rowHeights[0].height = 25; // è¡¨å¤´è¡Œé«˜
            }
            worksheet['!rows'] = rowHeights;

            // åº”ç”¨æ ·å¼
            const range = XLSX.utils.decode_range(worksheet['!ref']);

            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    if (!worksheet[cellAddress]) continue;

                    // æ£€æµ‹æ˜¯å¦ä¸ºç‰¹æ®Šè¡Œï¼ˆå¦‚æ€»è®¡è¡Œï¼‰
                    const cellValue = worksheet[cellAddress].v;
                    const isSpecialRow = cellValue && (
                        cellValue.toString().includes('æ€»è®¡') ||
                        cellValue.toString().includes('åˆè®¡') ||
                        cellValue.toString().includes('å°è®¡')
                    );

                    // åŸºç¡€æ ·å¼
                    worksheet[cellAddress].s = {
                        font: {
                            name: "å¾®è½¯é›…é»‘",
                            sz: 11,
                            bold: row === 0 || isSpecialRow // è¡¨å¤´å’Œç‰¹æ®Šè¡ŒåŠ ç²—
                        },
                        alignment: {
                            horizontal: row === 0 ? "center" : (isNumeric(cellValue) ? "right" : "left"),
                            vertical: "center",
                            wrapText: true
                        },
                        border: {
                            top: { style: "thin", color: { rgb: "CCCCCC" } },
                            bottom: { style: "thin", color: { rgb: "CCCCCC" } },
                            left: { style: "thin", color: { rgb: "CCCCCC" } },
                            right: { style: "thin", color: { rgb: "CCCCCC" } }
                        }
                    };

                    // è¡¨å¤´ç‰¹æ®Šæ ·å¼
                    if (row === 0) {
                        worksheet[cellAddress].s.fill = {
                            fgColor: { rgb: "E6F3FF" }
                        };
                        worksheet[cellAddress].s.font.color = { rgb: "2E5BBA" };
                    }

                    // å¢å¼ºæ•°æ®ç±»å‹æ£€æµ‹å’Œæ ¼å¼åŒ–
                    if (row > 0 && cellValue !== undefined) {
                        const cellStr = cellValue.toString();
                        const dataFormat = detectDataFormat(cellStr);

                        switch (dataFormat) {
                            case 'currency':
                                const numValue = extractNumericValue(cellStr);
                                const currencyType = getCurrencyType(cellStr);
                                if (numValue !== null && currencyType) {
                                    worksheet[cellAddress].v = numValue;
                                    worksheet[cellAddress].t = 'n';

                                    // è®¾ç½®è´§å¸æ ¼å¼
                                    const formatMap = {
                                        'Â¥': 'Â¥#,##0',
                                        '$': '$#,##0',
                                        'â‚¬': 'â‚¬#,##0',
                                        'Â£': 'Â£#,##0',
                                        'â‚¹': 'â‚¹#,##0',
                                        'â‚½': 'â‚½#,##0'
                                    };
                                    worksheet[cellAddress].s.numFmt = formatMap[currencyType] || '#,##0';
                                }
                                break;

                            case 'percentage':
                                const pctValue = extractNumericValue(cellStr);
                                if (pctValue !== null) {
                                    worksheet[cellAddress].v = pctValue;
                                    worksheet[cellAddress].t = 'n';
                                    worksheet[cellAddress].s.numFmt = '0.00%';
                                }
                                break;

                            case 'integer':
                                const intValue = extractNumericValue(cellStr);
                                if (intValue !== null) {
                                    worksheet[cellAddress].v = intValue;
                                    worksheet[cellAddress].t = 'n';
                                    worksheet[cellAddress].s.numFmt = '#,##0';
                                }
                                break;

                            case 'decimal':
                                const decValue = extractNumericValue(cellStr);
                                if (decValue !== null) {
                                    worksheet[cellAddress].v = decValue;
                                    worksheet[cellAddress].t = 'n';
                                    worksheet[cellAddress].s.numFmt = '#,##0.00';
                                }
                                break;

                            case 'date':
                                try {
                                    let dateValue;
                                    if (cellStr.includes('å¹´') && cellStr.includes('æœˆ')) {
                                        // å¤„ç†ä¸­æ–‡æ—¥æœŸ
                                        const cleaned = cellStr.replace(/å¹´/g, '-').replace(/æœˆ/g, '-').replace(/æ—¥/g, '');
                                        dateValue = new Date(cleaned);
                                    } else {
                                        dateValue = new Date(cellStr);
                                    }

                                    if (!isNaN(dateValue)) {
                                        worksheet[cellAddress].v = dateValue;
                                        worksheet[cellAddress].t = 'd';

                                        // æ ¹æ®æ—¥æœŸæ ¼å¼é€‰æ‹©æ˜¾ç¤ºæ ¼å¼
                                        if (cellStr.includes('å¹´')) {
                                            worksheet[cellAddress].s.numFmt = 'yyyyå¹´mmæœˆddæ—¥';
                                        } else if (cellStr.includes('/')) {
                                            worksheet[cellAddress].s.numFmt = 'yyyy/mm/dd';
                                        } else {
                                            worksheet[cellAddress].s.numFmt = 'yyyy-mm-dd';
                                        }
                                    }
                                } catch (e) {
                                    // æ—¥æœŸè§£æå¤±è´¥ï¼Œä¿æŒåŸæ–‡æœ¬
                                }
                                break;

                            case 'boolean':
                                // å¸ƒå°”å€¼è½¬æ¢
                                const boolMap = {
                                    'true': true, 'false': false,
                                    'æ˜¯': true, 'å¦': false,
                                    'æœ‰': true, 'æ— ': false,
                                    'âˆš': true, 'Ã—': false
                                };
                                const boolValue = boolMap[cellStr.toLowerCase()];
                                if (boolValue !== undefined) {
                                    worksheet[cellAddress].v = boolValue;
                                    worksheet[cellAddress].t = 'b';
                                }
                                break;

                            default:
                                // ä¿æŒä¸ºæ–‡æœ¬
                                break;
                        }
                    }
                }
            }

            return worksheet;
        }

        // åˆ›å»ºå†…å®¹å·¥ä½œè¡¨
        function createContentWorksheet(content) {
            const lines = content.split('\n').filter(line => line.trim());
            const data = [['è¡Œå·', 'å†…å®¹']];

            lines.forEach((line, index) => {
                data.push([index + 1, line.trim()]);
            });

            return createStyledWorksheet(data, "æ–‡æœ¬å†…å®¹");
        }

        // æ¸…ç†å•å…ƒæ ¼å†…å®¹ - å¢å¼ºç‰ˆ
        function cleanCellContent(content) {
            if (!content) return '';

            let cleaned = content.toString().trim();

            // ç§»é™¤Markdownæ ¼å¼æ ‡è®°
            cleaned = cleaned
                .replace(/\*\*(.*?)\*\*/g, '$1')     // ç§»é™¤åŠ ç²—æ ‡è®°
                .replace(/\*(.*?)\*/g, '$1')         // ç§»é™¤æ–œä½“æ ‡è®°
                .replace(/`(.*?)`/g, '$1')           // ç§»é™¤ä»£ç æ ‡è®°
                .replace(/~~(.*?)~~/g, '$1')         // ç§»é™¤åˆ é™¤çº¿æ ‡è®°
                .replace(/__(.*?)__/g, '$1')         // ç§»é™¤ä¸‹åˆ’çº¿åŠ ç²—
                .replace(/_(.*?)_/g, '$1');          // ç§»é™¤ä¸‹åˆ’çº¿æ–œä½“

            // ç§»é™¤HTMLæ ‡è®°ï¼ˆé˜²æ­¢å¤åˆ¶æ—¶å¸¦å…¥HTMLï¼‰
            cleaned = cleaned.replace(/<[^>]*>/g, '');

            // å¤„ç†ç‰¹æ®Šå­—ç¬¦
            cleaned = cleaned
                .replace(/&nbsp;/g, ' ')             // æ›¿æ¢éæ–­è¡Œç©ºæ ¼
                .replace(/&amp;/g, '&')              // æ›¿æ¢HTMLå®ä½“
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&quot;/g, '"');

            // ç§»é™¤å¤šä½™çš„ç©ºç™½å­—ç¬¦
            cleaned = cleaned.replace(/\s+/g, ' ').trim();

            return cleaned;
        }

        // å®¹é”™å¤„ç†å‡½æ•°
        function safeParseContent(content, fallbackType = 'article') {
            try {
                if (!content || typeof content !== 'string') {
                    return { type: fallbackType, content: content || '' };
                }

                const detectedType = detectContentType(content);
                return { type: detectedType, content: content };
            } catch (error) {
                console.warn('å†…å®¹è§£æå‡ºé”™ï¼Œä½¿ç”¨å¤‡ç”¨ç±»å‹:', error);
                return { type: fallbackType, content: content || '' };
            }
        }

        // å®‰å…¨çš„è¡¨æ ¼è§£æ
        function safeExtractTables(content) {
            try {
                return extractMarkdownTables(content);
            } catch (error) {
                console.warn('è¡¨æ ¼æå–å‡ºé”™:', error);
                // å°è¯•ç®€å•çš„è¡¨æ ¼æ£€æµ‹
                const lines = content.split('\n').filter(line => line.includes('|'));
                if (lines.length >= 2) {
                    const simpleTable = lines.map(line =>
                        line.split('|').map(cell => cleanCellContent(cell)).filter(cell => cell)
                    ).filter(row => row.length > 0);

                    if (simpleTable.length > 0) {
                        return [{
                            title: 'è¡¨æ ¼1',
                            data: simpleTable
                        }];
                    }
                }
                return [];
            }
        }

        // æ£€æµ‹æ˜¯å¦ä¸ºæ•°å­—ï¼ˆåŒ…æ‹¬å¸¦é€—å·çš„æ•°å­—ï¼‰- å¢å¼ºç‰ˆ
        function isNumeric(str) {
            if (!str || typeof str !== 'string') return false;

            // ç§»é™¤å¸¸è§çš„éæ•°å­—å­—ç¬¦ä½†ä¿ç•™æ•°å­—ç»“æ„
            const cleanStr = str.replace(/[Â¥$â‚¬Â£â‚¹â‚½,\s]/g, '').replace(/[()]/g, '');

            // æ£€æŸ¥ç™¾åˆ†æ¯”
            if (cleanStr.endsWith('%')) {
                const numPart = cleanStr.slice(0, -1);
                return !isNaN(numPart) && !isNaN(parseFloat(numPart)) && numPart !== '';
            }

            // æ£€æŸ¥æ™®é€šæ•°å­—ï¼ˆåŒ…æ‹¬è´Ÿæ•°å’Œå°æ•°ï¼‰
            if (/^-?\d+(\.\d+)?$/.test(cleanStr)) {
                return true;
            }

            // æ£€æŸ¥ç§‘å­¦è®¡æ•°æ³•
            if (/^-?\d+(\.\d+)?[eE][+-]?\d+$/.test(cleanStr)) {
                return true;
            }

            return false;
        }

        // æå–æ•°å­—å€¼ - å¢å¼ºç‰ˆ
        function extractNumericValue(str) {
            if (!str || typeof str !== 'string') return null;

            // å¤„ç†ç™¾åˆ†æ¯”
            if (str.includes('%')) {
                const numStr = str.replace(/[Â¥$â‚¬Â£â‚¹â‚½,\s%]/g, '');
                const num = parseFloat(numStr);
                return isNaN(num) ? null : num / 100; // è½¬æ¢ä¸ºå°æ•°
            }

            // å¤„ç†è´Ÿæ•°ï¼ˆæ‹¬å·è¡¨ç¤ºï¼‰
            let cleanStr = str;
            let isNegative = false;
            if (str.includes('(') && str.includes(')')) {
                cleanStr = str.replace(/[()]/g, '');
                isNegative = true;
            }

            // ç§»é™¤è´§å¸ç¬¦å·å’Œé€—å·ï¼Œä¿ç•™å°æ•°ç‚¹å’Œè´Ÿå·
            cleanStr = cleanStr.replace(/[Â¥$â‚¬Â£â‚¹â‚½,\s]/g, '');

            const num = parseFloat(cleanStr);
            if (isNaN(num)) return null;

            return isNegative ? -Math.abs(num) : num;
        }

        // æ£€æµ‹è´§å¸ç±»å‹ - å¢å¼ºç‰ˆ
        function getCurrencyType(str) {
            if (!str || typeof str !== 'string') return null;

            // æŒ‰ä¼˜å…ˆçº§æ£€æµ‹è´§å¸ç¬¦å·
            if (str.includes('Â¥')) return 'Â¥';
            if (str.includes('$')) return '$';
            if (str.includes('â‚¬')) return 'â‚¬';
            if (str.includes('Â£')) return 'Â£';
            if (str.includes('â‚¹')) return 'â‚¹';
            if (str.includes('â‚½')) return 'â‚½';

            // æ£€æµ‹è´§å¸å•ä½è¯
            if (/å…ƒ|äººæ°‘å¸/i.test(str)) return 'Â¥';
            if (/dollar|usd/i.test(str)) return '$';
            if (/euro|eur/i.test(str)) return 'â‚¬';
            if (/pound|gbp/i.test(str)) return 'Â£';

            return null;
        }

        // æ£€æµ‹æ•°æ®æ ¼å¼ç±»å‹
        function detectDataFormat(str) {
            if (!str || typeof str !== 'string') return 'text';

            const trimmed = str.trim();

            // æ£€æµ‹ç™¾åˆ†æ¯”
            if (trimmed.includes('%') && isNumeric(trimmed)) {
                return 'percentage';
            }

            // æ£€æµ‹è´§å¸
            if (getCurrencyType(trimmed) && isNumeric(trimmed)) {
                return 'currency';
            }

            // æ£€æµ‹æ—¥æœŸ
            if (isValidDate(trimmed)) {
                return 'date';
            }

            // æ£€æµ‹æ•°å­—
            if (isNumeric(trimmed)) {
                const num = extractNumericValue(trimmed);
                if (num !== null) {
                    return num % 1 === 0 ? 'integer' : 'decimal';
                }
            }

            // æ£€æµ‹å¸ƒå°”å€¼
            if (/^(true|false|æ˜¯|å¦|æœ‰|æ— |âˆš|Ã—)$/i.test(trimmed)) {
                return 'boolean';
            }

            return 'text';
        }

        // æ£€æµ‹æ˜¯å¦ä¸ºæœ‰æ•ˆæ—¥æœŸ - å¢å¼ºç‰ˆ
        function isValidDate(dateString) {
            if (!dateString || typeof dateString !== 'string') return false;

            const trimmed = dateString.trim();

            // å¸¸è§æ—¥æœŸæ ¼å¼æ¨¡å¼
            const datePatterns = [
                /^\d{4}[-/]\d{1,2}[-/]\d{1,2}$/,           // 2024-01-15, 2024/1/15
                /^\d{1,2}[-/]\d{1,2}[-/]\d{4}$/,           // 15-01-2024, 1/15/2024
                /^\d{4}å¹´\d{1,2}æœˆ\d{1,2}æ—¥$/,             // 2024å¹´1æœˆ15æ—¥
                /^\d{1,2}æœˆ\d{1,2}æ—¥$/,                    // 1æœˆ15æ—¥
                /^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}$/,  // 2024-01-15 10:30:00
                /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/,   // 2024-01-15T10:30:00
            ];

            // æ£€æŸ¥æ˜¯å¦åŒ¹é…æ—¥æœŸæ¨¡å¼
            const matchesPattern = datePatterns.some(pattern => pattern.test(trimmed));
            if (!matchesPattern) return false;

            // å°è¯•è§£ææ—¥æœŸ
            let date;
            try {
                // å¤„ç†ä¸­æ–‡æ—¥æœŸæ ¼å¼
                if (trimmed.includes('å¹´') && trimmed.includes('æœˆ')) {
                    const cleaned = trimmed.replace(/å¹´/g, '-').replace(/æœˆ/g, '-').replace(/æ—¥/g, '');
                    date = new Date(cleaned);
                } else {
                    date = new Date(trimmed);
                }

                // æ£€æŸ¥æ—¥æœŸæ˜¯å¦æœ‰æ•ˆä¸”åœ¨åˆç†èŒƒå›´å†…
                if (date instanceof Date && !isNaN(date)) {
                    const year = date.getFullYear();
                    return year >= 1900 && year <= 2100; // åˆç†çš„å¹´ä»½èŒƒå›´
                }
            } catch (e) {
                return false;
            }

            return false;
        }
    </script>
</body>
</html>