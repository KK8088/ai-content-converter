<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIÂÜÖÂÆπÊ†ºÂºèËΩ¨Êç¢Â∑•ÂÖ∑</title>
    <script src="https://cdn.jsdelivr.net/npm/docx@7.8.2/build/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
        /* ÂØºÂÖ•Áé∞‰ª£Â≠ó‰Ωì */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');

        /* CSSÂèòÈáèÂÆö‰πâ */
        :root {
            --primary-color: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #a5b4fc;
            --secondary-color: #f59e0b;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
            --info-color: #3b82f6;

            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --text-muted: #9ca3af;

            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-tertiary: #f3f4f6;
            --bg-dark: #111827;

            --border-color: #e5e7eb;
            --border-light: #f3f4f6;

            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);

            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;

            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* ÂÖ®Â±ÄÈáçÁΩÆ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Âü∫Á°ÄÊ†∑Âºè */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 1rem;
        }

        /* ‰∏ªÂÆπÂô® */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Â§¥ÈÉ®Âå∫Âüü */
        .header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 3rem 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="50" cy="50" r="1" fill="rgba(255,255,255,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.1;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            position: relative;
            z-index: 1;
        }

        .header .subtitle {
            font-size: 1.125rem;
            opacity: 0.9;
            font-weight: 400;
            position: relative;
            z-index: 1;
        }

        /* ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü */
        .main-content {
            padding: 2rem;
        }

        /* Âç°ÁâáÊ†∑Âºè */
        .card {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
        }

        .card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        /* ËæìÂÖ•Âå∫Âüü */
        .input-section {
            margin-bottom: 2rem;
        }

        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 1.5rem;
            background: var(--primary-color);
            border-radius: 2px;
        }

        /* ÊñáÊú¨Âå∫ÂüüÊ†∑Âºè */
        .textarea-container {
            position: relative;
            margin-bottom: 1rem;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            padding: 1rem;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            resize: vertical;
            transition: var(--transition);
            background: var(--bg-secondary);
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
            background: var(--bg-primary);
        }

        textarea::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        /* Ê†ºÂºèÊèêÁ§∫ */
        .format-hint {
            margin-top: 0.5rem;
            color: var(--text-muted);
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .format-hint::before {
            content: 'üí°';
            font-size: 1rem;
        }

        /* ÈÄâÈ°πÂå∫Âüü */
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .option-group {
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            padding: 1rem;
            border: 1px solid var(--border-color);
        }

        .option-label {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            display: block;
        }

        select, input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            transition: var(--transition);
            background: var(--bg-primary);
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        /* ÊåâÈíÆÊ†∑Âºè */
        .btn-group {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        button {
            flex: 1;
            padding: 0.875rem 1.5rem;
            border: none;
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Âä†ËΩΩÂä®Áîª */
        .loading {
            display: none;
            text-align: center;
            padding: 2rem;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin: 1rem 0;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Á§∫‰æãÂå∫Âüü */
        .examples {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border-radius: var(--radius-lg);
            padding: 2rem;
            margin-top: 2rem;
            border: 1px solid var(--border-light);
        }

        .examples h3 {
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .examples h3::before {
            content: 'üìö';
            font-size: 1.25rem;
        }

        .example-item {
            margin-bottom: 1.5rem;
        }

        .example-title {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        pre {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            padding: 1rem;
            margin: 0.5rem 0;
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: 0.8rem;
            overflow-x: auto;
            line-height: 1.5;
        }

        /* ÂìçÂ∫îÂºèËÆæËÆ° */
        @media (max-width: 768px) {
            body {
                padding: 0.5rem;
            }

            .header {
                padding: 2rem 1rem;
            }

            .header h1 {
                font-size: 2rem;
            }

            .main-content {
                padding: 1rem;
            }

            .options-grid {
                grid-template-columns: 1fr;
            }

            .btn-group {
                flex-direction: column;
            }

            textarea {
                min-height: 250px;
                font-size: 0.8rem;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.75rem;
            }

            .header .subtitle {
                font-size: 1rem;
            }

            .card {
                padding: 1rem;
            }
        }

        /* Âä®ÁîªÊïàÊûú */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card {
            animation: fadeIn 0.6s ease-out;
        }

        /* ÊªöÂä®Êù°Ê†∑Âºè */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Â§¥ÈÉ®Âå∫Âüü -->
        <div class="header">
            <h1>AIÂÜÖÂÆπÊ†ºÂºèËΩ¨Êç¢Â∑•ÂÖ∑</h1>
            <p class="subtitle">Â∞ÜAIÂØπËØùÂÜÖÂÆπÂÆåÁæéËΩ¨Êç¢‰∏∫‰∏ì‰∏öÁöÑWordÂíåExcelÊñáÊ°£</p>
        </div>

        <!-- ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü -->
        <div class="main-content">
            <!-- ËæìÂÖ•Âå∫Âüü -->
            <div class="card input-section">
                <h2 class="section-title">ÂÜÖÂÆπËæìÂÖ•</h2>
                <div class="textarea-container">
                    <textarea id="ai-content" placeholder="ËØ∑Âú®Ê≠§Á≤òË¥¥‰ªéChatGPT„ÄÅDeepSeekÁ≠âAIÂØπËØù‰∏≠Â§çÂà∂ÁöÑÂÜÖÂÆπ...

ÊîØÊåÅÁöÑÊ†ºÂºèÂåÖÊã¨Ôºö
‚Ä¢ MarkdownË°®Ê†º (| Âàó1 | Âàó2 |)
‚Ä¢ ‰ª£Á†ÅÂùó (```‰ª£Á†Å```)
‚Ä¢ ÂàóË°®È°πÁõÆ (- È°πÁõÆ Êàñ 1. È°πÁõÆ)
‚Ä¢ ÂºïÁî®ÂÜÖÂÆπ (> ÂºïÁî®)
‚Ä¢ Ê†áÈ¢òÊ†ºÂºè (# Ê†áÈ¢ò)
‚Ä¢ Ê†ºÂºèÂåñÊñáÊú¨ (**Âä†Á≤ó** *Êñú‰Ωì* `‰ª£Á†Å`)

Êô∫ËÉΩËØÜÂà´ÂêÑÁßçÊï∞ÊçÆÁ±ªÂûãÔºöË¥ßÂ∏Å„ÄÅÊó•Êúü„ÄÅÁôæÂàÜÊØîÁ≠â"></textarea>
                </div>
                <div class="format-hint">
                    ÊîØÊåÅÊ†ºÂºèÔºöMarkdownË°®Ê†º„ÄÅ‰ª£Á†ÅÂùó„ÄÅÂºïÁî®„ÄÅÂàóË°®„ÄÅÈìæÊé•„ÄÅÂä†Á≤óÊñú‰ΩìÁ≠â
                </div>
            </div>

            <!-- ÈÄâÈ°πÂå∫Âüü -->
            <div class="card">
                <h2 class="section-title">ËΩ¨Êç¢ÈÄâÈ°π</h2>
                <div class="options-grid">
                    <div class="option-group">
                        <label class="option-label" for="content-type">ÂÜÖÂÆπÁ±ªÂûã</label>
                        <select id="content-type">
                            <option value="auto">ü§ñ Êô∫ËÉΩÊ£ÄÊµã</option>
                            <option value="table">üìä Ë°®Ê†ºÊï∞ÊçÆ</option>
                            <option value="list">üìã ÂàóË°®/È°πÁõÆ</option>
                            <option value="article">üìÑ ÊñáÁ´†/Êä•Âëä</option>
                            <option value="markdown">üìù MarkdownÊ†ºÂºè</option>
                        </select>
                    </div>

                    <div class="option-group">
                        <label class="option-label" for="output-format">ËæìÂá∫Ê†ºÂºè</label>
                        <select id="output-format">
                            <option value="docx">üìÑ Microsoft Word (.docx)</option>
                            <option value="xlsx">üìä Microsoft Excel (.xlsx)</option>
                            <option value="both">üìÑüìä WordÂíåExcel</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Êìç‰ΩúÊåâÈíÆ -->
            <div class="btn-group">
                <button id="convert-btn" class="btn-primary">
                    üöÄ ÂºÄÂßãËΩ¨Êç¢
                </button>
                <button id="clear-btn" class="btn-secondary">
                    üóëÔ∏è Ê∏ÖÁ©∫ÂÜÖÂÆπ
                </button>
            </div>

            <!-- Âä†ËΩΩÁä∂ÊÄÅ -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p class="loading-text">Ê≠£Âú®Êô∫ËÉΩÂ§ÑÁêÜ‰∏≠ÔºåËØ∑Á®çÂÄô...</p>
            </div>
        
            <!-- Á§∫‰æãÂå∫Âüü -->
            <div class="examples">
                <h3>Ê†ºÂºèÁ§∫‰æã‰∏é‰ΩøÁî®ÊåáÂçó</h3>

                <div class="example-item">
                    <div class="example-title">üìä MarkdownË°®Ê†º</div>
                    <pre>| ‰∫ßÂìÅÂêçÁß∞ | ‰ª∑Ê†º | Â∫ìÂ≠ò | Áä∂ÊÄÅ |
|----------|------|------|------|
| iPhone 15 Pro | ¬•8,999.00 | 50 | ÊúâË¥ß |
| MacBook Air | $1,299.99 | 30 | ÊúâË¥ß |
| iPad Pro | ‚Ç¨999.50 | 25 | Áº∫Ë¥ß |</pre>
                </div>

                <div class="example-item">
                    <div class="example-title">üíª ‰ª£Á†ÅÂùó</div>
                    <pre>```javascript
function processData(data) {
    return data.map(item => ({
        id: item.id,
        value: parseFloat(item.value)
    }));
}
```</pre>
                </div>

                <div class="example-item">
                    <div class="example-title">üìã ÂàóË°®ÂíåÂºïÁî®</div>
                    <pre>## È°πÁõÆÊ∏ÖÂçï
- ÈúÄÊ±ÇÂàÜÊûê ‚úÖ
- Á≥ªÁªüËÆæËÆ° üîÑ
- ÂºÄÂèëÂÆûÊñΩ ‚è≥

> **ÈáçË¶ÅÊèêÁ§∫**: ËØ∑Á°Æ‰øùÊâÄÊúâÊï∞ÊçÆÂáÜÁ°ÆÊó†ËØØ</pre>
                </div>

                <div class="example-item">
                    <div class="example-title">üé® Ê†ºÂºèÂåñÊñáÊú¨</div>
                    <pre>**Âä†Á≤óÊñáÊú¨** *Êñú‰ΩìÊñáÊú¨* `Ë°åÂÜÖ‰ª£Á†Å`
[ÈìæÊé•ÊñáÊú¨](https://example.com)
~~Âà†Èô§Á∫ø~~ __‰∏ãÂàíÁ∫ø__</pre>
                </div>

                <div class="example-item">
                    <div class="example-title">üí∞ Êï∞ÊçÆÁ±ªÂûãÊîØÊåÅ</div>
                    <pre>Ë¥ßÂ∏Å: ¬•1,250.50, $999.99, ‚Ç¨850.00
ÁôæÂàÜÊØî: 15.6%, -8.2%, +23.8%
Êó•Êúü: 2024-03-15, 2024Âπ¥3Êúà16Êó•
Â∏ÉÂ∞î: ÊòØ/Âê¶, ‚àö/√ó, true/false</pre>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        document.getElementById('convert-btn').addEventListener('click', convertContent);
        document.getElementById('clear-btn').addEventListener('click', () => {
            document.getElementById('ai-content').value = '';
        });

        // Êô∫ËÉΩÊ£ÄÊµãÂÜÖÂÆπÁ±ªÂûã - Â¢ûÂº∫Áâà
        function detectContentType(content) {
            if (!content || !content.trim()) {
                return 'article';
            }

            const lines = content.split('\n').map(line => line.trim()).filter(line => line);
            const totalLines = lines.length;

            // ËÆ°ÁÆóÂêÑÁßçÊ†ºÂºèÁöÑÊùÉÈáç
            let markdownScore = 0;
            let tableScore = 0;
            let listScore = 0;
            let codeScore = 0;

            // Ê£ÄÊµãMarkdownË°®Ê†º - Êõ¥‰∏•Ê†ºÁöÑÊ£ÄÊµã
            const tableLines = lines.filter(line => line.includes('|'));
            const separatorLines = lines.filter(line => /^\|?[\s]*:?-+:?[\s]*\|/.test(line) || /^[\s]*:?-+:?[\s]*\|/.test(line));

            if (tableLines.length >= 2 && separatorLines.length >= 1) {
                // Ê£ÄÊü•Ë°®Ê†ºÁªìÊûÑÁöÑ‰∏ÄËá¥ÊÄß
                const tableLinesWithPipes = tableLines.filter(line => {
                    const pipeCount = (line.match(/\|/g) || []).length;
                    return pipeCount >= 2; // Ëá≥Â∞ëÈúÄË¶Å2‰∏™ÁÆ°ÈÅìÁ¨¶ÂΩ¢ÊàêË°®Ê†º
                });

                if (tableLinesWithPipes.length >= 2) {
                    tableScore += 50;
                    markdownScore += 30;
                }
            }

            // Ê£ÄÊµã‰ª£Á†ÅÂùó
            const codeBlockMatches = content.match(/```[\s\S]*?```/g);
            if (codeBlockMatches) {
                codeScore += codeBlockMatches.length * 20;
                markdownScore += 25;
            }

            // Ê£ÄÊµãÂçïË°å‰ª£Á†ÅÂùóÔºàÊ≤°ÊúâÁªìÊùüÊ†áËÆ∞ÁöÑÔºâ
            if (content.includes('```')) {
                markdownScore += 15;
            }

            // Ê£ÄÊµãÂºïÁî®Âùó
            const quoteLines = lines.filter(line => /^>\s/.test(line));
            if (quoteLines.length > 0) {
                markdownScore += quoteLines.length * 5;
            }

            // Ê£ÄÊµãMarkdownÊ†áÈ¢ò
            const headingLines = lines.filter(line => /^#{1,6}\s/.test(line));
            if (headingLines.length > 0) {
                markdownScore += headingLines.length * 10;
            }

            // Ê£ÄÊµãÂàóË°®
            const unorderedListLines = lines.filter(line => /^[-*+]\s/.test(line));
            const orderedListLines = lines.filter(line => /^\d+\.\s/.test(line));
            const totalListLines = unorderedListLines.length + orderedListLines.length;

            if (totalListLines > 0) {
                listScore += totalListLines * 8;
                markdownScore += totalListLines * 5;
            }

            // Ê£ÄÊµãMarkdownÈìæÊé•ÂíåÊ†ºÂºè
            const linkMatches = content.match(/\[([^\]]+)\]\(([^)]+)\)/g);
            if (linkMatches) {
                markdownScore += linkMatches.length * 3;
            }

            const boldMatches = content.match(/\*\*([^*]+)\*\*/g);
            if (boldMatches) {
                markdownScore += boldMatches.length * 2;
            }

            const italicMatches = content.match(/\*([^*]+)\*/g);
            if (italicMatches) {
                markdownScore += italicMatches.length * 1;
            }

            // Ê£ÄÊµãÁÆÄÂçïCSV
            if (isSimpleCSV(content)) {
                tableScore += 40;
            }

            // Ê£ÄÊµãÂàÜÈöîÁ∫ø
            const separatorCount = lines.filter(line => /^-{3,}$/.test(line)).length;
            if (separatorCount > 0) {
                markdownScore += separatorCount * 5;
            }

            // Ê†πÊçÆÊùÉÈáçÂÜ≥ÂÆöÂÜÖÂÆπÁ±ªÂûã
            const maxScore = Math.max(markdownScore, tableScore, listScore, codeScore);

            // Â¶ÇÊûúË°®Ê†ºÂàÜÊï∞ÊúÄÈ´ò‰∏îË∂ÖËøáÈòàÂÄº
            if (tableScore >= 30 && tableScore === maxScore) {
                return 'table';
            }

            // Â¶ÇÊûúMarkdownÂàÜÊï∞Ë∂ÖËøáÈòàÂÄº
            if (markdownScore >= 15) {
                return 'markdown';
            }

            // Â¶ÇÊûú‰∏ªË¶ÅÊòØÂàóË°®ÂÜÖÂÆπ
            if (listScore >= 20 && totalListLines / totalLines > 0.5) {
                return 'list';
            }

            // ÈªòËÆ§‰∏∫ÊñáÁ´†
            return 'article';
        }

        function isSimpleCSV(content) {
            const lines = content.split('\n').filter(line => line.trim());
            if (lines.length < 2) return false;

            // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´MarkdownË°®Ê†ºÊ†áËÆ∞
            if (content.includes('|') || content.includes('---')) {
                return false;
            }

            const firstLineCommas = (lines[0].match(/,/g) || []).length;
            if (firstLineCommas === 0) return false;

            // Ê£ÄÊü•ÂàóÊï∞‰∏ÄËá¥ÊÄß
            let consistentLines = 0;
            for (const line of lines) {
                const commas = (line.match(/,/g) || []).length;
                if (Math.abs(commas - firstLineCommas) <= 1) {
                    consistentLines++;
                }
            }

            // Ëá≥Â∞ë80%ÁöÑË°åÈúÄË¶ÅÊúâ‰∏ÄËá¥ÁöÑÂàóÊï∞
            const consistency = consistentLines / lines.length;
            return consistency >= 0.8 && firstLineCommas >= 1;
        }

        async function convertContent() {
            const content = document.getElementById('ai-content').value.trim();
            if (!content) {
                alert('ËØ∑ËæìÂÖ•Ë¶ÅËΩ¨Êç¢ÁöÑÂÜÖÂÆπ');
                return;
            }

            const contentType = document.getElementById('content-type').value;
            const outputFormat = document.getElementById('output-format').value;
            
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            
            try {
                // Ê®°ÊãüÂºÇÊ≠•Â§ÑÁêÜ
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                if (outputFormat === 'docx' || outputFormat === 'both') {
                    await generateDocx(content, contentType);
                }
                
                if (outputFormat === 'xlsx' || outputFormat === 'both') {
                    await generateXlsx(content, contentType);
                }
            } catch (error) {
                console.error('ËΩ¨Êç¢ÈîôËØØ:', error);
                alert('ËΩ¨Êç¢ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: ' + error.message);
            } finally {
                loading.style.display = 'none';
            }
        }

        async function generateDocx(content, contentType) {
            const {
                Document, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell,
                AlignmentType, BorderStyle, WidthType, LevelFormat, convertInchesToTwip,
                ShadingType, UnderlineType, ExternalHyperlink
            } = docx;

            const children = [];

            // Êô∫ËÉΩÊ£ÄÊµãÂÜÖÂÆπÁ±ªÂûã
            if (contentType === 'auto') {
                contentType = detectContentType(content);
            }

            // Ê†πÊçÆÂÜÖÂÆπÁ±ªÂûãÂ§ÑÁêÜ
            if (contentType === 'table' || (contentType === 'auto' && isSimpleCSV(content))) {
                // Ë°®Ê†ºÊï∞ÊçÆÂ§ÑÁêÜ
                const rows = content.split('\n').filter(row => row.trim());
                const tableRows = [];

                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    const isHeader = i === 0;
                    const cells = row.split(',').map(cell =>
                        new TableCell({
                            children: [new Paragraph({
                                children: [new TextRun({
                                    text: cell.trim(),
                                    bold: isHeader,
                                    font: "ÂæÆËΩØÈõÖÈªë",
                                    size: isHeader ? 24 : 22
                                })],
                                alignment: isHeader ? AlignmentType.CENTER : AlignmentType.LEFT
                            })],
                            shading: isHeader ? {
                                fill: "E6F3FF",
                                color: "auto"
                            } : undefined,
                            margins: {
                                top: convertInchesToTwip(0.1),
                                bottom: convertInchesToTwip(0.1),
                                left: convertInchesToTwip(0.15),
                                right: convertInchesToTwip(0.15)
                            },
                            borders: {
                                top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }
                            }
                        })
                    );
                    tableRows.push(new TableRow({
                        children: cells,
                        tableHeader: isHeader
                    }));
                }

                children.push(new Table({
                    rows: tableRows,
                    width: {
                        size: 100,
                        type: WidthType.PERCENTAGE
                    }
                }));
            } else if (contentType === 'list' || (contentType === 'auto' && content.startsWith('-'))) {
                // ÂàóË°®Êï∞ÊçÆÂ§ÑÁêÜ
                const items = content.split('\n').filter(line => line.trim());
                for (const item of items) {
                    const cleanText = item.replace(/^- /, '').trim();
                    children.push(new Paragraph({
                        children: [new TextRun({
                            text: cleanText,
                            font: "ÂæÆËΩØÈõÖÈªë",
                            size: 22
                        })],
                        bullet: {
                            level: 0
                        },
                        spacing: {
                            after: 120
                        }
                    }));
                }
            } else if (contentType === 'markdown') {
                // È´òÁ∫ßMarkdownËß£Êûê
                const parsedElements = parseMarkdown(content);
                children.push(...parsedElements);
            } else {
                // ÁÆÄÂçïÊñáÊú¨Â§ÑÁêÜ
                const parsedElements = parseSimpleText(content);
                children.push(...parsedElements);
            }

            // Ëß£ÊûêMarkdownÂÜÖÂÆπ
            function parseMarkdown(content) {
                const elements = [];
                const lines = content.split('\n');
                let i = 0;

                while (i < lines.length) {
                    const line = lines[i];

                    // Ë∑≥ËøáÁ©∫Ë°å
                    if (!line.trim()) {
                        i++;
                        continue;
                    }

                    // Ëß£Êûê‰ª£Á†ÅÂùó
                    if (line.startsWith('```')) {
                        const codeBlock = parseCodeBlock(lines, i);
                        elements.push(...codeBlock.elements);
                        i = codeBlock.nextIndex;
                        continue;
                    }

                    // Ëß£ÊûêË°®Ê†º
                    if (line.includes('|') && i + 1 < lines.length && lines[i + 1].includes('---')) {
                        const table = parseMarkdownTable(lines, i);
                        elements.push(table.element);
                        i = table.nextIndex;
                        continue;
                    }

                    // Ëß£ÊûêÊ†áÈ¢ò
                    if (line.match(/^#{1,6}\s/)) {
                        elements.push(parseHeading(line));
                        i++;
                        continue;
                    }

                    // Ëß£ÊûêÂºïÁî®Âùó
                    if (line.startsWith('> ')) {
                        const quote = parseQuoteBlock(lines, i);
                        elements.push(quote.element);
                        i = quote.nextIndex;
                        continue;
                    }

                    // Ëß£ÊûêÂàóË°®
                    if (line.match(/^[-*+]\s/) || line.match(/^\d+\.\s/)) {
                        const list = parseList(lines, i);
                        elements.push(...list.elements);
                        i = list.nextIndex;
                        continue;
                    }

                    // Ëß£ÊûêÂàÜÈöîÁ∫ø
                    if (line.match(/^---+$/)) {
                        elements.push(createSeparatorLine());
                        i++;
                        continue;
                    }

                    // Ëß£ÊûêÊôÆÈÄöÊÆµËêΩ
                    const paragraph = parseParagraph(lines, i);
                    if (paragraph.element) {
                        elements.push(paragraph.element);
                    }
                    i = paragraph.nextIndex;
                }

                return elements;
            }

            // Ëß£ÊûêÁÆÄÂçïÊñáÊú¨
            function parseSimpleText(content) {
                const elements = [];
                const lines = content.split('\n');
                let currentParagraph = '';

                for (const line of lines) {
                    if (line.trim() === '') {
                        if (currentParagraph.trim()) {
                            elements.push(createStyledParagraph(currentParagraph.trim()));
                            currentParagraph = '';
                        }
                    } else if (line.startsWith('# ')) {
                        if (currentParagraph.trim()) {
                            elements.push(createStyledParagraph(currentParagraph.trim()));
                            currentParagraph = '';
                        }
                        elements.push(parseHeading(line));
                    } else if (line.startsWith('## ')) {
                        if (currentParagraph.trim()) {
                            elements.push(createStyledParagraph(currentParagraph.trim()));
                            currentParagraph = '';
                        }
                        elements.push(parseHeading(line));
                    } else if (line.startsWith('### ')) {
                        if (currentParagraph.trim()) {
                            elements.push(createStyledParagraph(currentParagraph.trim()));
                            currentParagraph = '';
                        }
                        elements.push(parseHeading(line));
                    } else {
                        currentParagraph += (currentParagraph ? ' ' : '') + line.trim();
                    }
                }

                if (currentParagraph.trim()) {
                    elements.push(createStyledParagraph(currentParagraph.trim()));
                }

                return elements;
            }

            function createStyledParagraph(text) {
                return new Paragraph({
                    children: parseInlineFormatting(text),
                    alignment: AlignmentType.JUSTIFIED,
                    spacing: {
                        after: 120,
                        line: 276
                    },
                    indent: {
                        firstLine: convertInchesToTwip(0.5)
                    }
                });
            }

            // Ëß£ÊûêÊ†áÈ¢ò
            function parseHeading(line) {
                const match = line.match(/^(#{1,6})\s(.+)$/);
                if (!match) return null;

                const level = match[1].length;
                const text = match[2].trim();
                const headingLevels = [
                    HeadingLevel.HEADING_1, HeadingLevel.HEADING_2, HeadingLevel.HEADING_3,
                    HeadingLevel.HEADING_4, HeadingLevel.HEADING_5, HeadingLevel.HEADING_6
                ];
                const colors = ["2E5BBA", "4472C4", "5B9BD5", "70AD47", "FFC000", "C55A11"];
                const sizes = [32, 28, 24, 22, 20, 18];

                return new Paragraph({
                    children: [new TextRun({
                        text: text,
                        font: "ÂæÆËΩØÈõÖÈªë",
                        size: sizes[level - 1],
                        bold: true,
                        color: colors[level - 1]
                    })],
                    heading: headingLevels[level - 1],
                    alignment: AlignmentType.LEFT,
                    spacing: {
                        before: level === 1 ? 240 : 200 - (level - 1) * 20,
                        after: level === 1 ? 120 : 100 - (level - 1) * 10
                    }
                });
            }

            // Ëß£Êûê‰ª£Á†ÅÂùó
            function parseCodeBlock(lines, startIndex) {
                const elements = [];
                let i = startIndex + 1;
                const codeLines = [];
                let language = lines[startIndex].substring(3).trim();

                while (i < lines.length && !lines[i].startsWith('```')) {
                    codeLines.push(lines[i]);
                    i++;
                }

                const codeText = codeLines.join('\n');

                elements.push(new Paragraph({
                    children: [new TextRun({
                        text: codeText,
                        font: "Consolas",
                        size: 20
                    })],
                    shading: {
                        fill: "F8F8F8",
                        color: "auto"
                    },
                    spacing: {
                        before: 120,
                        after: 120
                    },
                    indent: {
                        left: convertInchesToTwip(0.5)
                    },
                    border: {
                        left: {
                            color: "CCCCCC",
                            space: 1,
                            style: "single",
                            size: 4
                        }
                    }
                }));

                return { elements, nextIndex: i + 1 };
            }

            // Ëß£ÊûêMarkdownË°®Ê†º
            function parseMarkdownTable(lines, startIndex) {
                const tableRows = [];
                let i = startIndex;

                // Ëß£ÊûêË°®Â§¥
                const headerLine = lines[i].trim();
                const headers = headerLine.split('|').map(h => h.trim()).filter(h => h);

                // Ë∑≥ËøáÂàÜÈöîÁ∫ø
                i += 2;

                // ÂàõÂª∫Ë°®Â§¥Ë°å
                const headerCells = headers.map(header =>
                    new TableCell({
                        children: [new Paragraph({
                            children: [new TextRun({
                                text: header,
                                font: "ÂæÆËΩØÈõÖÈªë",
                                size: 24,
                                bold: true
                            })],
                            alignment: AlignmentType.CENTER
                        })],
                        shading: {
                            fill: "E6F3FF",
                            color: "auto"
                        },
                        margins: {
                            top: convertInchesToTwip(0.1),
                            bottom: convertInchesToTwip(0.1),
                            left: convertInchesToTwip(0.15),
                            right: convertInchesToTwip(0.15)
                        },
                        borders: {
                            top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                            bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                            left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                            right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }
                        }
                    })
                );

                tableRows.push(new TableRow({
                    children: headerCells,
                    tableHeader: true
                }));

                // Ëß£ÊûêÊï∞ÊçÆË°å
                while (i < lines.length && lines[i].includes('|')) {
                    const rowLine = lines[i].trim();
                    const cells = rowLine.split('|').map(c => c.trim()).filter(c => c);

                    const rowCells = cells.map(cell =>
                        new TableCell({
                            children: [new Paragraph({
                                children: parseInlineFormatting(cell),
                                alignment: AlignmentType.LEFT
                            })],
                            margins: {
                                top: convertInchesToTwip(0.1),
                                bottom: convertInchesToTwip(0.1),
                                left: convertInchesToTwip(0.15),
                                right: convertInchesToTwip(0.15)
                            },
                            borders: {
                                top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                                right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" }
                            }
                        })
                    );

                    tableRows.push(new TableRow({ children: rowCells }));
                    i++;
                }

                const table = new Table({
                    rows: tableRows,
                    width: {
                        size: 100,
                        type: WidthType.PERCENTAGE
                    }
                });

                return { element: table, nextIndex: i };
            }

            // Ëß£ÊûêÂºïÁî®Âùó
            function parseQuoteBlock(lines, startIndex) {
                const quoteLines = [];
                let i = startIndex;

                while (i < lines.length && lines[i].startsWith('> ')) {
                    quoteLines.push(lines[i].substring(2).trim());
                    i++;
                }

                const quoteText = quoteLines.join(' ');

                const element = new Paragraph({
                    children: [new TextRun({
                        text: quoteText,
                        font: "ÂæÆËΩØÈõÖÈªë",
                        size: 22,
                        italics: true,
                        color: "666666"
                    })],
                    shading: {
                        fill: "F5F5F5",
                        color: "auto"
                    },
                    spacing: {
                        before: 120,
                        after: 120
                    },
                    indent: {
                        left: convertInchesToTwip(0.5)
                    },
                    border: {
                        left: {
                            color: "4472C4",
                            space: 1,
                            style: "single",
                            size: 6
                        }
                    }
                });

                return { element, nextIndex: i };
            }

            // Ëß£ÊûêÂàóË°®
            function parseList(lines, startIndex) {
                const elements = [];
                let i = startIndex;

                while (i < lines.length) {
                    const line = lines[i];
                    if (!line.match(/^[-*+]\s/) && !line.match(/^\d+\.\s/)) {
                        break;
                    }

                    const isOrdered = line.match(/^\d+\.\s/);
                    const text = line.replace(/^[-*+]\s/, '').replace(/^\d+\.\s/, '').trim();

                    elements.push(new Paragraph({
                        children: parseInlineFormatting(text),
                        bullet: isOrdered ? undefined : { level: 0 },
                        numbering: isOrdered ? { reference: "my-numbering", level: 0 } : undefined,
                        spacing: {
                            after: 120
                        }
                    }));

                    i++;
                }

                return { elements, nextIndex: i };
            }

            // Ëß£ÊûêÊÆµËêΩ
            function parseParagraph(lines, startIndex) {
                let text = '';
                let i = startIndex;

                while (i < lines.length && lines[i].trim() &&
                       !lines[i].match(/^#{1,6}\s/) &&
                       !lines[i].startsWith('```') &&
                       !lines[i].startsWith('> ') &&
                       !lines[i].match(/^[-*+]\s/) &&
                       !lines[i].match(/^\d+\.\s/) &&
                       !lines[i].includes('|')) {
                    text += (text ? ' ' : '') + lines[i].trim();
                    i++;
                }

                if (!text.trim()) {
                    return { element: null, nextIndex: i + 1 };
                }

                const element = new Paragraph({
                    children: parseInlineFormatting(text),
                    alignment: AlignmentType.JUSTIFIED,
                    spacing: {
                        after: 120,
                        line: 276
                    },
                    indent: {
                        firstLine: convertInchesToTwip(0.5)
                    }
                });

                return { element, nextIndex: i };
            }

            // Ëß£ÊûêË°åÂÜÖÊ†ºÂºè
            function parseInlineFormatting(text) {
                const runs = [];
                let currentText = text;

                // ÁÆÄÂåñÁöÑË°åÂÜÖÊ†ºÂºèËß£Êûê
                const parts = currentText.split(/(\*\*[^*]+\*\*|\*[^*]+\*|`[^`]+`|\[[^\]]+\]\([^)]+\))/);

                for (const part of parts) {
                    if (!part) continue;

                    if (part.startsWith('**') && part.endsWith('**')) {
                        // Âä†Á≤ó
                        runs.push(new TextRun({
                            text: part.slice(2, -2),
                            bold: true,
                            font: "ÂæÆËΩØÈõÖÈªë",
                            size: 22
                        }));
                    } else if (part.startsWith('*') && part.endsWith('*')) {
                        // Êñú‰Ωì
                        runs.push(new TextRun({
                            text: part.slice(1, -1),
                            italics: true,
                            font: "ÂæÆËΩØÈõÖÈªë",
                            size: 22
                        }));
                    } else if (part.startsWith('`') && part.endsWith('`')) {
                        // Ë°åÂÜÖ‰ª£Á†Å
                        runs.push(new TextRun({
                            text: part.slice(1, -1),
                            font: "Consolas",
                            size: 20,
                            shading: {
                                fill: "F0F0F0",
                                color: "auto"
                            }
                        }));
                    } else if (part.match(/\[[^\]]+\]\([^)]+\)/)) {
                        // ÈìæÊé•
                        const linkMatch = part.match(/\[([^\]]+)\]\(([^)]+)\)/);
                        if (linkMatch) {
                            runs.push(new TextRun({
                                text: linkMatch[1],
                                font: "ÂæÆËΩØÈõÖÈªë",
                                size: 22,
                                color: "0563C1",
                                underline: {
                                    type: UnderlineType.SINGLE,
                                    color: "0563C1"
                                }
                            }));
                        }
                    } else {
                        // ÊôÆÈÄöÊñáÊú¨
                        runs.push(new TextRun({
                            text: part,
                            font: "ÂæÆËΩØÈõÖÈªë",
                            size: 22
                        }));
                    }
                }

                return runs.length > 0 ? runs : [new TextRun({
                    text: text,
                    font: "ÂæÆËΩØÈõÖÈªë",
                    size: 22
                })];
            }

            // ÂàõÂª∫ÂàÜÈöîÁ∫ø
            function createSeparatorLine() {
                return new Paragraph({
                    children: [new TextRun("")],
                    border: {
                        bottom: {
                            color: "CCCCCC",
                            space: 1,
                            style: "single",
                            size: 6
                        }
                    },
                    spacing: {
                        before: 120,
                        after: 120
                    }
                });
            }

            const doc = new Document({
                creator: "AIÂÜÖÂÆπÊ†ºÂºèËΩ¨Êç¢Â∑•ÂÖ∑",
                title: "ËΩ¨Êç¢ÊñáÊ°£",
                description: "Áî±AIÂÜÖÂÆπÊ†ºÂºèËΩ¨Êç¢Â∑•ÂÖ∑ÁîüÊàê",
                styles: {
                    paragraphStyles: [
                        {
                            id: "Normal",
                            name: "Normal",
                            basedOn: "Normal",
                            next: "Normal",
                            run: {
                                font: "ÂæÆËΩØÈõÖÈªë",
                                size: 22
                            },
                            paragraph: {
                                spacing: {
                                    line: 276,
                                    after: 120
                                }
                            }
                        }
                    ]
                },
                numbering: {
                    config: [
                        {
                            reference: "my-bullet-points",
                            levels: [
                                {
                                    level: 0,
                                    format: LevelFormat.BULLET,
                                    text: "‚óè",
                                    alignment: AlignmentType.LEFT,
                                    style: {
                                        paragraph: {
                                            indent: {
                                                left: convertInchesToTwip(0.5),
                                                hanging: convertInchesToTwip(0.25)
                                            }
                                        }
                                    }
                                }
                            ]
                        },
                        {
                            reference: "my-numbering",
                            levels: [
                                {
                                    level: 0,
                                    format: LevelFormat.DECIMAL,
                                    text: "%1.",
                                    alignment: AlignmentType.LEFT,
                                    style: {
                                        paragraph: {
                                            indent: {
                                                left: convertInchesToTwip(0.5),
                                                hanging: convertInchesToTwip(0.25)
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    ]
                },
                sections: [{
                    properties: {
                        page: {
                            margin: {
                                top: convertInchesToTwip(1),
                                right: convertInchesToTwip(1),
                                bottom: convertInchesToTwip(1),
                                left: convertInchesToTwip(1)
                            }
                        }
                    },
                    children: children
                }]
            });

            // ÁîüÊàêÂπ∂‰∏ãËΩΩDOCXÊñá‰ª∂
            const blob = await docx.Packer.toBlob(doc);
            saveAs(blob, 'converted_content.docx');
        }

        async function generateXlsx(content, contentType) {
            const workbook = XLSX.utils.book_new();

            // Êô∫ËÉΩÊ£ÄÊµãÂÜÖÂÆπÁ±ªÂûã
            if (contentType === 'auto') {
                contentType = detectContentType(content);
            }

            if (contentType === 'markdown') {
                // Â§ÑÁêÜMarkdownÂÜÖÂÆπÔºåÊèêÂèñÊâÄÊúâË°®Ê†º
                const tables = safeExtractTables(content);
                if (tables.length > 0) {
                    // Â§ÑÁêÜÂ§ö‰∏™Ë°®Ê†º
                    tables.forEach((table, index) => {
                        try {
                            const safeTitle = (table.title || `Ë°®Ê†º${index + 1}`).substring(0, 31); // ExcelÂ∑•‰ΩúË°®ÂêçÈôêÂà∂
                            const worksheet = createStyledWorksheet(table.data, safeTitle);
                            XLSX.utils.book_append_sheet(workbook, worksheet, safeTitle);
                        } catch (error) {
                            console.warn(`Ë°®Ê†º${index + 1}Â§ÑÁêÜÂá∫Èîô:`, error);
                            // ÂàõÂª∫ÁÆÄÂçïÁöÑÈîôËØØË°®Ê†º
                            const errorData = [['ÈîôËØØ', 'Ë°®Ê†ºÂ§ÑÁêÜÂ§±Ë¥•'], ['ÂéüÂõ†', error.message || 'Êú™Áü•ÈîôËØØ']];
                            const errorSheet = createStyledWorksheet(errorData, `ÈîôËØØ${index + 1}`);
                            XLSX.utils.book_append_sheet(workbook, errorSheet, `ÈîôËØØ${index + 1}`);
                        }
                    });
                } else {
                    // Ê≤°ÊúâË°®Ê†ºÔºåÂ§ÑÁêÜÂÖ∂‰ªñÂÜÖÂÆπ
                    const worksheet = createContentWorksheet(content);
                    XLSX.utils.book_append_sheet(workbook, worksheet, "ÂÜÖÂÆπ");
                }
            } else if (contentType === 'table' || isSimpleCSV(content)) {
                // ÁÆÄÂçïCSVË°®Ê†ºÂ§ÑÁêÜ
                const rows = content.split('\n').filter(row => row.trim()).map(row => row.split(',').map(cell => cell.trim()));
                const worksheet = createStyledWorksheet(rows, "Êï∞ÊçÆË°®");
                XLSX.utils.book_append_sheet(workbook, worksheet, "Êï∞ÊçÆË°®");
            } else if (contentType === 'list') {
                // ÂàóË°®Êï∞ÊçÆÂ§ÑÁêÜ
                const items = content.split('\n').filter(line => line.trim());
                const listData = [['È°πÁõÆ', 'ÂÜÖÂÆπ']];
                items.forEach((item, index) => {
                    const cleanText = item.replace(/^[-*+]\s/, '').replace(/^\d+\.\s/, '').trim();
                    listData.push([index + 1, cleanText]);
                });
                const worksheet = createStyledWorksheet(listData, "ÂàóË°®Êï∞ÊçÆ");
                XLSX.utils.book_append_sheet(workbook, worksheet, "ÂàóË°®Êï∞ÊçÆ");
            } else {
                // ÊôÆÈÄöÊñáÊú¨Â§ÑÁêÜ
                const worksheet = createContentWorksheet(content);
                XLSX.utils.book_append_sheet(workbook, worksheet, "ÊñáÊú¨ÂÜÖÂÆπ");
            }

            // ÁîüÊàêÂπ∂‰∏ãËΩΩXLSXÊñá‰ª∂
            XLSX.writeFile(workbook, 'converted_content.xlsx');
        }

        // ÊèêÂèñMarkdownË°®Ê†º - Â¢ûÂº∫Áâà
        function extractMarkdownTables(content) {
            const tables = [];
            const lines = content.split('\n');
            let i = 0;
            let currentTitle = '';

            while (i < lines.length) {
                const line = lines[i].trim();

                // Ë∑≥ËøáÁ©∫Ë°å
                if (!line) {
                    i++;
                    continue;
                }

                // Ê£ÄÊµãÊ†áÈ¢ò
                if (line.match(/^#{1,6}\s/)) {
                    currentTitle = line.replace(/^#{1,6}\s/, '').trim();
                    i++;
                    continue;
                }

                // Ê£ÄÊµãË°®Ê†ºÂºÄÂßã - Êõ¥ÁÅµÊ¥ªÁöÑÊ£ÄÊµã
                if (isTableStart(lines, i)) {
                    const tableResult = parseTable(lines, i, currentTitle || `Ë°®Ê†º${tables.length + 1}`);
                    if (tableResult.data.length > 0) {
                        tables.push(tableResult);
                    }
                    i = tableResult.nextIndex;
                    currentTitle = ''; // ÈáçÁΩÆÊ†áÈ¢ò
                    continue;
                }

                i++;
            }

            return tables;
        }

        // Ê£ÄÊµãË°®Ê†ºÂºÄÂßã
        function isTableStart(lines, index) {
            if (index >= lines.length) return false;

            const currentLine = lines[index].trim();
            if (!currentLine.includes('|')) return false;

            // Ê£ÄÊü•‰∏ã‰∏ÄË°åÊòØÂê¶‰∏∫ÂàÜÈöîÁ∫ø
            if (index + 1 < lines.length) {
                const nextLine = lines[index + 1].trim();
                // Êõ¥ÁÅµÊ¥ªÁöÑÂàÜÈöîÁ∫øÊ£ÄÊµã
                if (isSeparatorLine(nextLine)) {
                    return true;
                }
            }

            // Â¶ÇÊûúÊ≤°ÊúâÂàÜÈöîÁ∫øÔºåÊ£ÄÊü•ÊòØÂê¶‰∏∫ËøûÁª≠ÁöÑË°®Ê†ºË°å
            if (index + 1 < lines.length) {
                const nextLine = lines[index + 1].trim();
                if (nextLine.includes('|')) {
                    // Ê£ÄÊü•ÁÆ°ÈÅìÁ¨¶Êï∞ÈáèÊòØÂê¶Áõ∏‰ºº
                    const currentPipes = (currentLine.match(/\|/g) || []).length;
                    const nextPipes = (nextLine.match(/\|/g) || []).length;
                    return Math.abs(currentPipes - nextPipes) <= 1 && currentPipes >= 2;
                }
            }

            return false;
        }

        // Ê£ÄÊµãÂàÜÈöîÁ∫ø
        function isSeparatorLine(line) {
            // Ê†áÂáÜMarkdownÂàÜÈöîÁ∫ø
            if (/^\|?[\s]*:?-+:?[\s]*(\|[\s]*:?-+:?[\s]*)*\|?$/.test(line)) {
                return true;
            }
            // ÁÆÄÂåñÁöÑÂàÜÈöîÁ∫ø
            if (/^[-|:\s]+$/.test(line) && line.includes('-')) {
                return true;
            }
            return false;
        }

        // Ëß£ÊûêË°®Ê†º
        function parseTable(lines, startIndex, title) {
            const tableData = [];
            let i = startIndex;

            // Ëß£ÊûêË°®Â§¥
            const headerLine = lines[i].trim();
            const headers = parseTableRow(headerLine);
            if (headers.length > 0) {
                tableData.push(headers);
                i++;
            }

            // Ë∑≥ËøáÂàÜÈöîÁ∫øÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
            if (i < lines.length && isSeparatorLine(lines[i].trim())) {
                i++;
            }

            // Ëß£ÊûêÊï∞ÊçÆË°å
            while (i < lines.length) {
                const line = lines[i].trim();
                if (!line) {
                    i++;
                    continue;
                }

                if (!line.includes('|')) {
                    break;
                }

                const cells = parseTableRow(line);
                if (cells.length > 0) {
                    // Á°Æ‰øùÂàóÊï∞‰∏ÄËá¥ÊÄß
                    while (cells.length < headers.length) {
                        cells.push('');
                    }
                    if (cells.length > headers.length) {
                        cells.splice(headers.length);
                    }
                    tableData.push(cells);
                }
                i++;
            }

            return {
                title: title,
                data: tableData,
                nextIndex: i
            };
        }

        // Ëß£ÊûêË°®Ê†ºË°å
        function parseTableRow(line) {
            if (!line || !line.includes('|')) return [];

            // ÁßªÈô§È¶ñÂ∞æÁöÑÁÆ°ÈÅìÁ¨¶
            let cleanLine = line.trim();
            if (cleanLine.startsWith('|')) {
                cleanLine = cleanLine.substring(1);
            }
            if (cleanLine.endsWith('|')) {
                cleanLine = cleanLine.substring(0, cleanLine.length - 1);
            }

            // ÂàÜÂâ≤Âπ∂Ê∏ÖÁêÜÂçïÂÖÉÊ†º
            return cleanLine.split('|')
                .map(cell => cleanCellContent(cell.trim()))
                .filter((cell, index, arr) => {
                    // ‰øùÁïôÁ©∫ÂçïÂÖÉÊ†ºÔºå‰ΩÜÁßªÈô§ÂÆåÂÖ®Á©∫ÁöÑÂ∞æÈÉ®ÂçïÂÖÉÊ†º
                    if (index === arr.length - 1 && cell === '') {
                        return false;
                    }
                    return true;
                });
        }

        // ÂàõÂª∫Â∏¶Ê†∑ÂºèÁöÑÂ∑•‰ΩúË°®
        function createStyledWorksheet(data, title) {
            const worksheet = XLSX.utils.aoa_to_sheet(data);

            // ËÆæÁΩÆÂàóÂÆΩ
            const colWidths = [];
            if (data.length > 0) {
                for (let col = 0; col < data[0].length; col++) {
                    let maxWidth = 10;
                    for (let row = 0; row < data.length; row++) {
                        if (data[row][col]) {
                            const cellLength = String(data[row][col]).length;
                            maxWidth = Math.max(maxWidth, Math.min(cellLength * 1.2, 50));
                        }
                    }
                    colWidths.push({ width: maxWidth });
                }
            }
            worksheet['!cols'] = colWidths;

            // ËÆæÁΩÆË°åÈ´ò
            const rowHeights = data.map(() => ({ height: 20 }));
            if (rowHeights.length > 0) {
                rowHeights[0].height = 25; // Ë°®Â§¥Ë°åÈ´ò
            }
            worksheet['!rows'] = rowHeights;

            // Â∫îÁî®Ê†∑Âºè
            const range = XLSX.utils.decode_range(worksheet['!ref']);

            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    if (!worksheet[cellAddress]) continue;

                    // Ê£ÄÊµãÊòØÂê¶‰∏∫ÁâπÊÆäË°åÔºàÂ¶ÇÊÄªËÆ°Ë°åÔºâ
                    const cellValue = worksheet[cellAddress].v;
                    const isSpecialRow = cellValue && (
                        cellValue.toString().includes('ÊÄªËÆ°') ||
                        cellValue.toString().includes('ÂêàËÆ°') ||
                        cellValue.toString().includes('Â∞èËÆ°')
                    );

                    // Âü∫Á°ÄÊ†∑Âºè
                    worksheet[cellAddress].s = {
                        font: {
                            name: "ÂæÆËΩØÈõÖÈªë",
                            sz: 11,
                            bold: row === 0 || isSpecialRow // Ë°®Â§¥ÂíåÁâπÊÆäË°åÂä†Á≤ó
                        },
                        alignment: {
                            horizontal: row === 0 ? "center" : (isNumeric(cellValue) ? "right" : "left"),
                            vertical: "center",
                            wrapText: true
                        },
                        border: {
                            top: { style: "thin", color: { rgb: "CCCCCC" } },
                            bottom: { style: "thin", color: { rgb: "CCCCCC" } },
                            left: { style: "thin", color: { rgb: "CCCCCC" } },
                            right: { style: "thin", color: { rgb: "CCCCCC" } }
                        }
                    };

                    // Ë°®Â§¥ÁâπÊÆäÊ†∑Âºè
                    if (row === 0) {
                        worksheet[cellAddress].s.fill = {
                            fgColor: { rgb: "E6F3FF" }
                        };
                        worksheet[cellAddress].s.font.color = { rgb: "2E5BBA" };
                    }

                    // Â¢ûÂº∫Êï∞ÊçÆÁ±ªÂûãÊ£ÄÊµãÂíåÊ†ºÂºèÂåñ
                    if (row > 0 && cellValue !== undefined) {
                        const cellStr = cellValue.toString();
                        const dataFormat = detectDataFormat(cellStr);

                        switch (dataFormat) {
                            case 'currency':
                                const numValue = extractNumericValue(cellStr);
                                const currencyType = getCurrencyType(cellStr);
                                if (numValue !== null && currencyType) {
                                    worksheet[cellAddress].v = numValue;
                                    worksheet[cellAddress].t = 'n';

                                    // ËÆæÁΩÆË¥ßÂ∏ÅÊ†ºÂºè
                                    const formatMap = {
                                        '¬•': '¬•#,##0',
                                        '$': '$#,##0',
                                        '‚Ç¨': '‚Ç¨#,##0',
                                        '¬£': '¬£#,##0',
                                        '‚Çπ': '‚Çπ#,##0',
                                        '‚ÇΩ': '‚ÇΩ#,##0'
                                    };
                                    worksheet[cellAddress].s.numFmt = formatMap[currencyType] || '#,##0';
                                }
                                break;

                            case 'percentage':
                                const pctValue = extractNumericValue(cellStr);
                                if (pctValue !== null) {
                                    worksheet[cellAddress].v = pctValue;
                                    worksheet[cellAddress].t = 'n';
                                    worksheet[cellAddress].s.numFmt = '0.00%';
                                }
                                break;

                            case 'integer':
                                const intValue = extractNumericValue(cellStr);
                                if (intValue !== null) {
                                    worksheet[cellAddress].v = intValue;
                                    worksheet[cellAddress].t = 'n';
                                    worksheet[cellAddress].s.numFmt = '#,##0';
                                }
                                break;

                            case 'decimal':
                                const decValue = extractNumericValue(cellStr);
                                if (decValue !== null) {
                                    worksheet[cellAddress].v = decValue;
                                    worksheet[cellAddress].t = 'n';
                                    worksheet[cellAddress].s.numFmt = '#,##0.00';
                                }
                                break;

                            case 'date':
                                try {
                                    let dateValue;
                                    if (cellStr.includes('Âπ¥') && cellStr.includes('Êúà')) {
                                        // Â§ÑÁêÜ‰∏≠ÊñáÊó•Êúü
                                        const cleaned = cellStr.replace(/Âπ¥/g, '-').replace(/Êúà/g, '-').replace(/Êó•/g, '');
                                        dateValue = new Date(cleaned);
                                    } else {
                                        dateValue = new Date(cellStr);
                                    }

                                    if (!isNaN(dateValue)) {
                                        worksheet[cellAddress].v = dateValue;
                                        worksheet[cellAddress].t = 'd';

                                        // Ê†πÊçÆÊó•ÊúüÊ†ºÂºèÈÄâÊã©ÊòæÁ§∫Ê†ºÂºè
                                        if (cellStr.includes('Âπ¥')) {
                                            worksheet[cellAddress].s.numFmt = 'yyyyÂπ¥mmÊúàddÊó•';
                                        } else if (cellStr.includes('/')) {
                                            worksheet[cellAddress].s.numFmt = 'yyyy/mm/dd';
                                        } else {
                                            worksheet[cellAddress].s.numFmt = 'yyyy-mm-dd';
                                        }
                                    }
                                } catch (e) {
                                    // Êó•ÊúüËß£ÊûêÂ§±Ë¥•Ôºå‰øùÊåÅÂéüÊñáÊú¨
                                }
                                break;

                            case 'boolean':
                                // Â∏ÉÂ∞îÂÄºËΩ¨Êç¢
                                const boolMap = {
                                    'true': true, 'false': false,
                                    'ÊòØ': true, 'Âê¶': false,
                                    'Êúâ': true, 'Êó†': false,
                                    '‚àö': true, '√ó': false
                                };
                                const boolValue = boolMap[cellStr.toLowerCase()];
                                if (boolValue !== undefined) {
                                    worksheet[cellAddress].v = boolValue;
                                    worksheet[cellAddress].t = 'b';
                                }
                                break;

                            default:
                                // ‰øùÊåÅ‰∏∫ÊñáÊú¨
                                break;
                        }
                    }
                }
            }

            return worksheet;
        }

        // ÂàõÂª∫ÂÜÖÂÆπÂ∑•‰ΩúË°®
        function createContentWorksheet(content) {
            const lines = content.split('\n').filter(line => line.trim());
            const data = [['Ë°åÂè∑', 'ÂÜÖÂÆπ']];

            lines.forEach((line, index) => {
                data.push([index + 1, line.trim()]);
            });

            return createStyledWorksheet(data, "ÊñáÊú¨ÂÜÖÂÆπ");
        }

        // Ê∏ÖÁêÜÂçïÂÖÉÊ†ºÂÜÖÂÆπ - Â¢ûÂº∫Áâà
        function cleanCellContent(content) {
            if (!content) return '';

            let cleaned = content.toString().trim();

            // ÁßªÈô§MarkdownÊ†ºÂºèÊ†áËÆ∞
            cleaned = cleaned
                .replace(/\*\*(.*?)\*\*/g, '$1')     // ÁßªÈô§Âä†Á≤óÊ†áËÆ∞
                .replace(/\*(.*?)\*/g, '$1')         // ÁßªÈô§Êñú‰ΩìÊ†áËÆ∞
                .replace(/`(.*?)`/g, '$1')           // ÁßªÈô§‰ª£Á†ÅÊ†áËÆ∞
                .replace(/~~(.*?)~~/g, '$1')         // ÁßªÈô§Âà†Èô§Á∫øÊ†áËÆ∞
                .replace(/__(.*?)__/g, '$1')         // ÁßªÈô§‰∏ãÂàíÁ∫øÂä†Á≤ó
                .replace(/_(.*?)_/g, '$1');          // ÁßªÈô§‰∏ãÂàíÁ∫øÊñú‰Ωì

            // ÁßªÈô§HTMLÊ†áËÆ∞ÔºàÈò≤Ê≠¢Â§çÂà∂Êó∂Â∏¶ÂÖ•HTMLÔºâ
            cleaned = cleaned.replace(/<[^>]*>/g, '');

            // Â§ÑÁêÜÁâπÊÆäÂ≠óÁ¨¶
            cleaned = cleaned
                .replace(/&nbsp;/g, ' ')             // ÊõøÊç¢ÈùûÊñ≠Ë°åÁ©∫Ê†º
                .replace(/&amp;/g, '&')              // ÊõøÊç¢HTMLÂÆû‰Ωì
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&quot;/g, '"');

            // ÁßªÈô§Â§ö‰ΩôÁöÑÁ©∫ÁôΩÂ≠óÁ¨¶
            cleaned = cleaned.replace(/\s+/g, ' ').trim();

            return cleaned;
        }

        // ÂÆπÈîôÂ§ÑÁêÜÂáΩÊï∞
        function safeParseContent(content, fallbackType = 'article') {
            try {
                if (!content || typeof content !== 'string') {
                    return { type: fallbackType, content: content || '' };
                }

                const detectedType = detectContentType(content);
                return { type: detectedType, content: content };
            } catch (error) {
                console.warn('ÂÜÖÂÆπËß£ÊûêÂá∫ÈîôÔºå‰ΩøÁî®Â§áÁî®Á±ªÂûã:', error);
                return { type: fallbackType, content: content || '' };
            }
        }

        // ÂÆâÂÖ®ÁöÑË°®Ê†ºËß£Êûê
        function safeExtractTables(content) {
            try {
                return extractMarkdownTables(content);
            } catch (error) {
                console.warn('Ë°®Ê†ºÊèêÂèñÂá∫Èîô:', error);
                // Â∞ùËØïÁÆÄÂçïÁöÑË°®Ê†ºÊ£ÄÊµã
                const lines = content.split('\n').filter(line => line.includes('|'));
                if (lines.length >= 2) {
                    const simpleTable = lines.map(line =>
                        line.split('|').map(cell => cleanCellContent(cell)).filter(cell => cell)
                    ).filter(row => row.length > 0);

                    if (simpleTable.length > 0) {
                        return [{
                            title: 'Ë°®Ê†º1',
                            data: simpleTable
                        }];
                    }
                }
                return [];
            }
        }

        // Ê£ÄÊµãÊòØÂê¶‰∏∫Êï∞Â≠óÔºàÂåÖÊã¨Â∏¶ÈÄóÂè∑ÁöÑÊï∞Â≠óÔºâ- Â¢ûÂº∫Áâà
        function isNumeric(str) {
            if (!str || typeof str !== 'string') return false;

            // ÁßªÈô§Â∏∏ËßÅÁöÑÈùûÊï∞Â≠óÂ≠óÁ¨¶‰ΩÜ‰øùÁïôÊï∞Â≠óÁªìÊûÑ
            const cleanStr = str.replace(/[¬•$‚Ç¨¬£‚Çπ‚ÇΩ,\s]/g, '').replace(/[()]/g, '');

            // Ê£ÄÊü•ÁôæÂàÜÊØî
            if (cleanStr.endsWith('%')) {
                const numPart = cleanStr.slice(0, -1);
                return !isNaN(numPart) && !isNaN(parseFloat(numPart)) && numPart !== '';
            }

            // Ê£ÄÊü•ÊôÆÈÄöÊï∞Â≠óÔºàÂåÖÊã¨Ë¥üÊï∞ÂíåÂ∞èÊï∞Ôºâ
            if (/^-?\d+(\.\d+)?$/.test(cleanStr)) {
                return true;
            }

            // Ê£ÄÊü•ÁßëÂ≠¶ËÆ°Êï∞Ê≥ï
            if (/^-?\d+(\.\d+)?[eE][+-]?\d+$/.test(cleanStr)) {
                return true;
            }

            return false;
        }

        // ÊèêÂèñÊï∞Â≠óÂÄº - Â¢ûÂº∫Áâà
        function extractNumericValue(str) {
            if (!str || typeof str !== 'string') return null;

            // Â§ÑÁêÜÁôæÂàÜÊØî
            if (str.includes('%')) {
                const numStr = str.replace(/[¬•$‚Ç¨¬£‚Çπ‚ÇΩ,\s%]/g, '');
                const num = parseFloat(numStr);
                return isNaN(num) ? null : num / 100; // ËΩ¨Êç¢‰∏∫Â∞èÊï∞
            }

            // Â§ÑÁêÜË¥üÊï∞ÔºàÊã¨Âè∑Ë°®Á§∫Ôºâ
            let cleanStr = str;
            let isNegative = false;
            if (str.includes('(') && str.includes(')')) {
                cleanStr = str.replace(/[()]/g, '');
                isNegative = true;
            }

            // ÁßªÈô§Ë¥ßÂ∏ÅÁ¨¶Âè∑ÂíåÈÄóÂè∑Ôºå‰øùÁïôÂ∞èÊï∞ÁÇπÂíåË¥üÂè∑
            cleanStr = cleanStr.replace(/[¬•$‚Ç¨¬£‚Çπ‚ÇΩ,\s]/g, '');

            const num = parseFloat(cleanStr);
            if (isNaN(num)) return null;

            return isNegative ? -Math.abs(num) : num;
        }

        // Ê£ÄÊµãË¥ßÂ∏ÅÁ±ªÂûã - Â¢ûÂº∫Áâà
        function getCurrencyType(str) {
            if (!str || typeof str !== 'string') return null;

            // Êåâ‰ºòÂÖàÁ∫ßÊ£ÄÊµãË¥ßÂ∏ÅÁ¨¶Âè∑
            if (str.includes('¬•')) return '¬•';
            if (str.includes('$')) return '$';
            if (str.includes('‚Ç¨')) return '‚Ç¨';
            if (str.includes('¬£')) return '¬£';
            if (str.includes('‚Çπ')) return '‚Çπ';
            if (str.includes('‚ÇΩ')) return '‚ÇΩ';

            // Ê£ÄÊµãË¥ßÂ∏ÅÂçï‰ΩçËØç
            if (/ÂÖÉ|‰∫∫Ê∞ëÂ∏Å/i.test(str)) return '¬•';
            if (/dollar|usd/i.test(str)) return '$';
            if (/euro|eur/i.test(str)) return '‚Ç¨';
            if (/pound|gbp/i.test(str)) return '¬£';

            return null;
        }

        // Ê£ÄÊµãÊï∞ÊçÆÊ†ºÂºèÁ±ªÂûã
        function detectDataFormat(str) {
            if (!str || typeof str !== 'string') return 'text';

            const trimmed = str.trim();

            // Ê£ÄÊµãÁôæÂàÜÊØî
            if (trimmed.includes('%') && isNumeric(trimmed)) {
                return 'percentage';
            }

            // Ê£ÄÊµãË¥ßÂ∏Å
            if (getCurrencyType(trimmed) && isNumeric(trimmed)) {
                return 'currency';
            }

            // Ê£ÄÊµãÊó•Êúü
            if (isValidDate(trimmed)) {
                return 'date';
            }

            // Ê£ÄÊµãÊï∞Â≠ó
            if (isNumeric(trimmed)) {
                const num = extractNumericValue(trimmed);
                if (num !== null) {
                    return num % 1 === 0 ? 'integer' : 'decimal';
                }
            }

            // Ê£ÄÊµãÂ∏ÉÂ∞îÂÄº
            if (/^(true|false|ÊòØ|Âê¶|Êúâ|Êó†|‚àö|√ó)$/i.test(trimmed)) {
                return 'boolean';
            }

            return 'text';
        }

        // Ê£ÄÊµãÊòØÂê¶‰∏∫ÊúâÊïàÊó•Êúü - Â¢ûÂº∫Áâà
        function isValidDate(dateString) {
            if (!dateString || typeof dateString !== 'string') return false;

            const trimmed = dateString.trim();

            // Â∏∏ËßÅÊó•ÊúüÊ†ºÂºèÊ®°Âºè
            const datePatterns = [
                /^\d{4}[-/]\d{1,2}[-/]\d{1,2}$/,           // 2024-01-15, 2024/1/15
                /^\d{1,2}[-/]\d{1,2}[-/]\d{4}$/,           // 15-01-2024, 1/15/2024
                /^\d{4}Âπ¥\d{1,2}Êúà\d{1,2}Êó•$/,             // 2024Âπ¥1Êúà15Êó•
                /^\d{1,2}Êúà\d{1,2}Êó•$/,                    // 1Êúà15Êó•
                /^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}$/,  // 2024-01-15 10:30:00
                /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/,   // 2024-01-15T10:30:00
            ];

            // Ê£ÄÊü•ÊòØÂê¶ÂåπÈÖçÊó•ÊúüÊ®°Âºè
            const matchesPattern = datePatterns.some(pattern => pattern.test(trimmed));
            if (!matchesPattern) return false;

            // Â∞ùËØïËß£ÊûêÊó•Êúü
            let date;
            try {
                // Â§ÑÁêÜ‰∏≠ÊñáÊó•ÊúüÊ†ºÂºè
                if (trimmed.includes('Âπ¥') && trimmed.includes('Êúà')) {
                    const cleaned = trimmed.replace(/Âπ¥/g, '-').replace(/Êúà/g, '-').replace(/Êó•/g, '');
                    date = new Date(cleaned);
                } else {
                    date = new Date(trimmed);
                }

                // Ê£ÄÊü•Êó•ÊúüÊòØÂê¶ÊúâÊïà‰∏îÂú®ÂêàÁêÜËåÉÂõ¥ÂÜÖ
                if (date instanceof Date && !isNaN(date)) {
                    const year = date.getFullYear();
                    return year >= 1900 && year <= 2100; // ÂêàÁêÜÁöÑÂπ¥‰ªΩËåÉÂõ¥
                }
            } catch (e) {
                return false;
            }

            return false;
        }
    </script>
</body>
</html>